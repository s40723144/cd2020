var tipuesearch = {"pages": [{'title': 'About', 'text': 'Repository ： https://github.com/s40723144/cd2020 \n Website： https://s40723144.github.io/cd2020/content/index.html \n Group\xa0Repository： https://github.com/s40723150/cd2020ag2 \n Group Presentation： https://s40723150.github.io/cd2020ag2/reveal \n Group Website： https://s40723150.github.io/cd2020ag2 \n', 'tags': '', 'url': 'About.html'}, {'title': '紀錄', 'text': '', 'tags': '', 'url': '紀錄.html'}, {'title': 'w3', 'text': '可攜系統更新python3.8.2 \n \n', 'tags': '', 'url': 'w3.html'}, {'title': 'w7', 'text': '直播測試 \n 利用obs串流yt拍直播影片 \n \n 翻譯Assignment1.2和編輯個人簡介 \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w8', 'text': '期中影片學習報告 \n', 'tags': '', 'url': 'w8.html'}, {'title': 'w9.10', 'text': '學習如何使用CoppeliaSim \n \n 了解CoppeliaSim主要由模型和場景組成，而場景又細分成環境、腳本等等，同樣模型主要是實體的運用等等。除了這些還有作一些簡單的操作 \n \n \n', 'tags': '', 'url': 'w9.10.html'}, {'title': 'w11', 'text': '學習如何使用CoppeliaSim Camera的部分 \n', 'tags': '', 'url': 'w11.html'}, {'title': 'Assignment 1', 'text': '', 'tags': '', 'url': 'Assignment 1.html'}, {'title': 'CoppeliaSim User Manual', 'text': '目錄 \n \n User interface(用戶界面) \n Scenes and models(場景和模型) \n Environment(環境) \n Entities(實體) \n Simulation(模擬) \n \n', 'tags': '', 'url': 'CoppeliaSim User Manual.html'}, {'title': 'User interface(用戶界面)', 'text': 'The CoppeliaSim application is composed by several elements. Its main elements are: \n CoppeliaSim應用程序由幾個元素組成。 它的主要元素是： \n \n \n a console window: \xa0under Windows, when the CoppeliaSim application starts, a console window is created but directly hidden again. \n \n window控制台： 在Windows下，當CoppeliaSim應用 程式啟動時 ，會 創建一個控制台窗口 ，但會直接將其隱藏。 \n \n \xa0 an application window: \xa0the application window is the application\'s main window. It is used to display, edit, simulate and interact with a scene. \n \n window應用程式： 應用程式窗口是應用程式的主窗口。它用於 顯示、編輯模擬 並與場景交互。 \n \n several dialogs:\xa0 next to the application window, the user can also edit and interact with a scene by adjusting dialog settings or parameters.\xa0 \n \n 幾個對話框： 在應用程序窗口旁邊，用戶還可以通過 調整對話框的設置或參數 來編輯和與場景進行交互。 \n \n Following illustrates a typical view of the CoppeliaSim application: \n 以下是CoppeliaSim應用程序的典型視圖： \n \n \n When you launch the CoppeliaSim application, CoppeliaSim will initialized one default scene. The user is free to open several scenes in parallel.\xa0 \n In following section, a brief description will be given of the application window\'s elements. \n 當您啟動CoppeliaSim應用程序時，CoppeliaSim將初始化一個默認場景。 用戶可以自由地並行打開多個場景。 \n 在下一節中，將簡要介紹上圖應用程序窗口的元素。 \n \n \n application bar:  the application bar indicates the type of license of your CoppeliaSim copy, the filename of the scene that is currently being displayed, the time used for one rendering pass (one display pass), and the simulator\'s current state (simulation state or type of the active edit mode).\xa0Supported files include "*.ttt"-files (CoppeliaSim scene files) and "*.ttm"-files (CoppeliaSim model files). \n \n 應用程序欄： 應用程序欄指示您的 CoppeliaSim副本的許可類型，當前正在顯示的場景的文件名 ，一次解釋過程（一次顯示過程）所用的時間以及模擬器的當前狀態（模擬狀態或活動活動類型的編輯模式）。支持的文件包括“ *  .ttt”文件 （CoppeliaSim 場景文件 ）和“ * .ttm”文件（CoppeliaSim 模型文件 ）。 \n \n menu bar:  the menu bar allows accessing almost all functionalities of the simulator. Most of the time, the items in the menu bar activate a dialog. The menu bar content is context-sensitive (i.e. it will depend on the current state of the simulator). Most functions in the menu bar can also alternatively be accessed through a popup menu, a double-click on an icon in the scene hierarchy view, or through a click of a toolbar button. \n \n 菜單欄： 菜單欄 允許進入模擬器的幾乎所有功能 。 大多數時候，菜單欄中的項目會激活一個對話框。 菜單欄的內容是上下文相關的（即，它將取決於模擬器的當前狀態）。 也可以通過 彈出菜單 ，或者 雙擊場景階層 視圖中的圖標又或者 單擊工具欄按鈕 來進入菜單欄中的大多數功能。 \n \n toolbars:  the toolbars present functions that are often accessed (e.g. changing the navigation mode, selecting another page, etc.). Some functions in toolbar 1, and all functions in toolbar 2 can also be accessed through the menu bar or popup menu. See further down for more details. Both toolbars can be docked and undocked, but docking works only with their respective initial positions. Following figure explains each toolbar button\'s function: \n \n 工具欄： 工具欄提供經常進入的功能 （例如，更改導航模式，選擇其他頁面等）。  工具欄1 中的某些功能以及 工具欄2 中的所有功能也可以通過菜單欄或彈出菜單進入。 進一步了解更多細節。  這兩個工具欄都可以停靠任務和取消停靠任務 ，但是停靠任務僅適用於它們各自的初始位置。 下圖說明了每個工具欄按鈕的功能： \n \n \n model browser:  the model browser is visible by default, but can be toggled with its corresponding toolbar button. It displays in its upper part a CoppeliaSim model folder structure, and in its lower part, thumbnails of models contained in the selected folder. Thumbnails can be dragged-and-dropped into the scene to automatically load the related model. Caught thumbnails appears dark if the drop area is not supported or not appropriate. \n \n 模型瀏覽器： 默認情況下，模型瀏覽器是可見的，但可以使用其相應的工具欄按鈕進行切換。 它的 上部顯示CoppeliaSim模型結構的文件夾，下部顯示所選文件夾中包含的模型縮略圖 。 可以將縮略圖拖放到場景中以自動加載相關模型。 如果 拖放區域不受支持或不合適，則捕獲的縮略圖將顯示為黑色 。 \n \n \n \n scene hierarchy: the scene hierarchy is visible by default, but can be toggled with its corresponding toolbar button. It displays the content of a scene (i.e. all scene objects composing a scene). Since \xa0 scene objects \xa0 are built in a hierarchy-like structure, the scene hierarchy displays a tree of this hierarchy, and individual elements can be expanded or collapsed. A double-click on an icon opens/closes a property dialog related to the clicked icon. A double-click on an object name allows editing it. The mouse wheel as well as a drag of the scene hierarchy view\'s scrollbars allows shifting the content up/down or left/right. Control and shift selection is always supported. Objects in the scene hierarchy can be dragged and dropped onto another object, in order to create a parent-child relationship. The scene hierarchy will display a different content if the simulator is in an edit-mode state. Refer to the \xa0 shape edit modes , and the \xa0 path edit mode \xa0 for more information. \n \n \n 場景層次結構： 默認情況下，場景層次結構是可見的，但可以使用其相應的工具欄按鈕進行切換。 它顯示場景的內容（即組成場景的所有場景對象）。 由於場景對像是按類似層次結構的結構構建的，因此 場景層次結構將顯示此層次結構的樹狀圖，並且各個元素都可以展開或折疊。 雙擊圖標可打開/關閉與單擊的圖標相關的屬性對話框。 雙擊對象名稱可以對其進行編輯 。 鼠標滾輪以及場景層次結構視圖的拖動允許向上/向下或向左/向右移動內容。 始終支持控制和換檔選擇。  可以將場景層次結構中的對象拖放到另一個對像上，以創建鄰接表模型 。 如果模擬器處於編輯模式狀態，則場景層次將顯示不同的內容。 有關更多信息，請參考形狀編輯模式和路徑編輯模式。 \n \n \n page:   each \xa0 scene \xa0 may contain up to 8 pages, each of them may contain an unlimited number of views. A page can be seen as container for views. Refer to the \xa0 pages and views section \xa0 for more details. \n \n 頁面： 每個場景最多可包含8個頁面 ，每個頁面可包含不限數量的視圖。可以將頁面視為視圖的容器。請參閱頁面和視圖部分以獲取更多詳細信息。 \n \n views:   there can be an unlimited number of views contained in a page. A view is used to display the scene (itself containing an environment and objects), seen through a \xa0 viewable object \xa0 (e.g. \xa0 cameras , \xa0 graphs \xa0 or \xa0 vision sensors ). \n \n 視圖： 頁面中可以包含無數個視圖。 視圖用於顯示通過可見對象 （例如攝像機，圖形或視覺傳感器） 看到的場景 （本身包含環境和對象）。 \n \n information text:  the information text displays information related to current object/item selection and to running simulation states or parameters. The text display can be toggled with one of the two small buttons on the upper left side of a page. The other button can be used to toggle a white background, giving a better contrast depending on the background color of a scene. \n \n 信息文本： 信息文本顯示與當前對象/項目選擇以及運行模擬狀態或參數有關的信息。可以使用頁面 左上方的兩個小按鈕之一來切換文本顯示。另一個按鈕可用於切換白色背景 ，根據場景的背景顏色提供更好的對比度。 \n \n status bar: \xa0 the status bar displays information related to performed operations, commands, and also displays error messages from the Lua interpreter. From within a\xa0 script \xa0the user can also output strings to the status bar with the\xa0 sim.addStatusbarMessage \xa0function. The status bar displays only two lines by default, but it can be resized using its horizontal separation handle. \n \n 狀態欄： 狀態欄 顯示與執行的操作，命令有關的信息 ，還顯示來自Lua解釋器的錯誤消息 。用戶還可 以從腳本中使用\xa0 (sim.addStatusbarMessage)\xa0 函數將字符串輸出到狀態欄 。默認情況下，狀態欄僅顯示兩行，但可以使用其水平分隔手柄調整其大小。 \n \n Lua commander:   a read-eval-print loop, that adds a text input to the CoppeliaSim status bar, allowing to enter and execute Lua code on the fly, like in a terminal. The code can be run in \xa0 the sandbox script , or any other active script in CoppeliaSim. \n \n Lua指令： 一個讀-評估-打印循環 ，它將文本輸入添加到CoppeliaSim狀態欄，從而可以像在終端機中一樣快速輸入和執行Lua代碼。 該代碼可以在沙盒腳本或CoppeliaSim中的任何其他活動腳本中運行。 \n \n custom user interfaces: \xa0 custom user interfaces \xa0are user-defined UI surfaces that can be used to display information (text, images, etc.) or a custom dialog, allowing to interact with the user in a customized way. \n \n 自定義用戶界面： 自定義用戶界面是用戶定義的UI表面，可用於顯示信息（文本，圖像等）或自定義對話框 ，從而允許以自定義方式與用戶進行交互。 \n \n popup menu:  popup menus are the menus that appear after a right mouse button click. To activate a popup menu, make sure the mouse doesn\'t move during the click operation, otherwise the camera rotation mode may be activated (see the  camera section \xa0for more details). Each surface within the application window (e.g. scene hierarchy view, page, view, etc.) may trigger a different popup menu (context-sensitive). The content of popup menus may also change depending on the current simulation state or edit mode. Most popup menu function can also be accessed through the menu bar, except for the view-menu item that only appears when the popup menu is activated on a view or page. \n \n 彈出菜單：彈出菜單是單擊鼠標右鍵後出現的菜單。要激活彈出菜單，請確保在單擊操作期間鼠標沒有移動，否則可能會激活相機旋轉模式（有關更多詳細信息，請參見相機部分）。應用程序窗口內的每個表面（例如，場景層次視圖，頁面，視圖等）可能會觸發不同的彈出菜單（上下文相關）。 彈出菜單的內容可能根據當前的模擬狀態或編輯模式而改變。除了僅在視圖或頁面上激活彈出菜單時才會顯示的視圖菜單項，大多數彈出菜單功能也可以通過菜單欄進入。 \n', 'tags': '', 'url': 'User interface(用戶界面).html'}, {'title': 'Scenes and models(場景和模型)', 'text': 'Scenes and models are CoppeliaSim\'s main simulation elements. A model is a sub-element of a scene, clearly marked as model. A scene may contain any number of models. Following figure illustrates the scene-model relationship: \n 場景和模型是CoppeliaSim的主要模擬元素。  模型是場景的子元素，明確標記為模型。 場景可以包含任何數量的模型。  下圖說明了場景模型關係： \n \n Scenes(場景) \n Compared to\xa0 models , a scene can contain exactly the same type of elements, but additionally also includes following elements, specific to scenes: \n 與模型相比，場景可以包含完全相同類型的元素，但另外還包括以下特定於場景的元素： \n \n \n \n The environment \n The main script \n Pages and views \n \n \n \n \n \n \n \n 環境 \n 主要腳本 \n 頁面和視圖 \n \n \n A scene or scene image content can be seen through a\xa0 viewable object \xa0 associated with a view, itself contained in a \xa0 page . When creating a new scene ([Menu bar --> File --> New Scene]), the default scene will contain following elements: \n 可以通過與視圖相關聯的可視對象（本身包含在頁面中）來查看場景或場景圖像內容。創建新場景時（ [菜單欄->文件->新場景] ），默認場景將包含以下元素： \n \n \n Several\xa0 camera objects :  cameras allow to \xa0 see \xa0 the scene if they are associated with a view. \n Several\xa0 light objects :  without a light the scene would be hardly visible. The light is used to illuminate the scene. \n Several\xa0 views :  a view is associated with a camera and displays what the camera \xa0 sees . Views are contained in pages. \n Several\xa0 pages :  a page contains one or several views. \n The environment :  the environment is composed by properties as ambient light, fog, background color, etc. \n The floor:  the floor is made-up by\xa0 objects \xa0 grouped in a model. \n The default\xa0 main script :  the default main script should allow running minimal simulations, without the need of \xa0 child scripts . A child script copied into the scene at a later stage will then also be automatically executed (called by the main script) if it is associated with a scene object. \n \n \n 幾個攝影機對象： 如果攝影機與視圖關聯，則可以查看場景。 \n 幾個燈光對象： 沒有燈光，幾乎看不到場景。燈光用於照亮場景。 \n 幾個視圖： 一個視圖與相機關聯，並顯示相機看到的內容。視圖包含在頁面中。 \n 多個頁面： 一個頁麵包含一個或多個視圖。 \n 環境： 環境由環境光，霧，背景色等屬性組成。 \n 地板： 地板是由模型中分組的對象組成的。 \n 默認主腳本： 默認主腳本應允許運行最少的模擬，而無需子腳本 。如果子腳本與場景對象相關聯，則在稍後階段複製到場景中的子腳本也將自動執行（由主腳本調用）。 \n \n \n Scenes can be opened (loaded) with [Menu bar --> File --> Open Scene...] and saved with [Menu bar --> File --> Save Scene] or [Menu Bar --> File --> Save Scene as...]. Scene files ("*.ttt"-files) also support drag and drop operations between the explorer window and the application window. Scene files can also be double-clicked, in which case they will launch the CoppeliaSim application and be opened. \n 可以使用 [菜單欄->文件->打開場景...]打開（加載）場景，並使用[菜單欄->文件->保存場景]或[菜單欄->文件- >將場景另存為...]。 場景文件（“ * .ttt”文件） 還支持資源管理器窗口和應用程序窗口之間的拖放操作。 也可以雙擊場景文件，在這種情況下，它們將啟動CoppeliaSim應用程序並打開。 \n Switching between opened scene can be achieved with a single click in the upper part of the \xa0 scene hierarchy \xa0 (all opened scenes are grouped at the top of the scene hierarchy), or by using the scene selector via its related toolbar button: \n 只需在場景階層結構的上部單擊即可 切換打開的場景 （所有打開的場景都在場景階層結構的頂部分組），或者通 過與其相關的工具欄按鈕使用場景選擇器 來實現： \n \n model(模型) \n A model is a sub-element of a\xa0 scene . A model by itself cannot exist, except in a file ("*.ttm"-file type), nor can it be simulated by itself. A model has to be contained in a scene in order to be operational. \n 模型是場景的子元素。 除了文件（ “ * .ttm”-文件類型 ）外， 模型本身不能存在，也不能通過自身進行模擬。 模型必須包含在場景中才能運行。 \n Models are defined by a selection of\xa0 scene objects \xa0 built on a same hierarchy tree, where the base of the tree has to be an object flagged as \xa0 object is model base . They can be loaded with [Menu bar --> File --> Load model...]. It is however much easier and convenient to load a model with a drag-and-drop operation between the \xa0 model browser \xa0 and a \xa0 scene view . Models can be saved with [Menu bar --> File --> Save model as...], just make sure one single object flagged as \xa0 object is model base \xa0 is selected, otherwise the \xa0 Save model as... -menu item will not be enabled. Make also sure to follow the \xa0 tutorial on how to build a clean simulation model . \n 通過在同一階層樹 狀圖上構建的場景對象的選擇來定義模型，其中樹狀圖的基礎必須是已標記對像是模型基礎的對象。\xa0 可以通過[菜單欄->文件->加載模型...]加載它們。 但是，通過在模型瀏覽器和場景視圖之間進行拖放操作來加載模型更加容易和方便。 可以使用[菜單欄->文件->將模型另存為...]保存模型，只需要確認已標註的單個對象是不是選擇的基礎模型 ，否則將模型另存為...-菜單項 未啟用(沒辦法)。 還請確保遵循有關如何構建清晰仿真模型的教程。 \n A model is defined in following steps: \n 通過以下步驟定義模型： \n \n \n attach all objects that logically belong to the model to a base object, so that the base object is the base of the model tree. \n \n 將邏輯上屬於模型的所有對象附加到基礎對象 ，以便基礎對像是模型樹狀圖的基礎。 \n \n check the\xa0 object is model base -item in the   \xa0 object common properties . \n \n 在通用屬性中檢查對象是不是模型基礎項目 \n \n in the same dialog as above, check the\xa0 object/model can transfer or accept DNA -item. This will simplify model re-instanciation if you modify it at a later stage. \n \n 在與上述相同的對話框中， 檢查對象/模型是否可以轉移或接受DNA項目 。 如果稍後進行修改，這將簡化模型的重新實例化。 \n \n in the same dialog as above, clicking\xa0 Edit model properties , you can define special overriding properties (e.g. make the whole model invisible, non-collidable, etc.). That allows to quickly disable some properties for all objects defined in the model. \n \n 在與上述相同的對話框中， 點擊編輯模型屬性，您可以定義特殊的替代屬性（例如，使整個模型不可見，不碰撞等） 。 這樣可以快速禁用模型中定義的所有對象的某些屬性。 \n \n for all objects in the model, except for the base object, check the\xa0 select base of model instead -item in the  \xa0 object common properties . This will protect your model: you won\'t be able to directly select individual objects in your model, and you will be able to manipulate your model almost as a single object. \n \n 對於模型中的所有對象（基礎對象除外），請 檢查對象通用屬性中的模型選擇基礎代替項目 。 這將保護您的模型： 您將無法直接選擇模型中的單個對象，並且幾乎可以將其作為單個對象來操作模型。 \n \n for all objects that are normally not visible, check the\xa0 Don\'t show as inside model selection -item. This will make the model bounding box appear in the right size around the model. \n \n 對於通常不常見的所有對象，請選中“不顯示內部模型”選擇項 。 這將使模型邊界框在模型周圍以正確的尺寸顯示。 \n \n think about the role of the model: will you be able to attach it to some other object? (e.g. your model is a gripper that you could attach to a manipulator wrist). Or will you be able to attach some other model to it? (e.g. your model is a manipulator that could accept a gripper model). Once the role is decided, define the model\'s\xa0 assembling behaviour . Refer also to this \xa0 dynamics design consideration . \n \n 考慮一下模型的作用： 您能否將其附加到其他對像上？ （例如，您的模型是可以連接到機械手腕上的抓手）。 還是可以附加一些其他模型？ （例如，您的模型是可以接受機械手模型的操縱器）。  確定角色後，定義模型的組裝行為。   另請參閱此動力學設計注意事項。 \n \n Now, individual objects build on the model base cannot be selected anymore in the scene (selecting them will select the base of the model instead), however they can still be individually selected by holding down the ctrl- and shift-key during selection, or by selecting them in the \xa0 scene hierarchy . In addition to that, when the base object is selected, a stippled bounding box encompassing the whole model is displayed as can be seen in following figure: \n 現在，無法在場景中選擇建立在模型基礎上的單個對象（選擇它們將改為選擇模型的基礎），但是仍然 可以通過在選擇過程中按住ctrl和Shift鍵來單獨選擇它們，或者 通過在場景層次中選擇它們。 除此之外，當選擇基礎對象時，將顯示一個包圍整個模型的點畫邊界框 ，如下圖所示： \n \n Notice the model tag on the left-hand side of the icon of the object flagged as model base: \n 注意標記為模型庫的對像圖標左側的模型標籤： \n \n A double-click on a model tag opens the \xa0 model dialog , where model properties can be adjusted. It is also good practice to collapse a model\'s hierarchy once the model was edited in order to easily identify the number of logically grouped elements/models: \n 雙擊模型標籤可打開模型對話框，可在其中調整模型屬性。  修改模型的階層結構後，就是還不錯折疊模型的階層結構，以輕鬆識別邏輯分組的元素/模型的數量： \n \n Grouping several objects as a model is also important when a\xa0 child script \xa0 accesses the objects programmatically; remember that in CoppeliaSim, objects/models can be duplicated at any time, also during a simulation. In order for the duplicated child script to be able to access the correct objects (not the original objects but the duplicated objects), the child script should always be duplicated at the same time as the objects it accesses. One way to guaranty that is to create a model (as described above) and to make sure the child scripts that access objects in the model are associated with objects that are contained in the model. Best is to associate one child script (there might be secondary child scripts too) with the the base of the model. Refer to the \xa0 accessing objects programmatically section \xa0 for more information. \n 當子腳本以編程方式進入對象時，將多個對象分組成模型也很重要 。 請記住，在CoppeliaSim中，對象/模型可以隨時復制，甚至在模擬過程中也可以復制。  為了使復制的子腳本能夠進入正確的對象 （不是原始對象，而是複制的對象），應始終 在進入子腳本的同時復制子腳本。 保證的一種方法是 創建模型 （如上所述）， 並確保進入模型中對象的子腳本與模型中包含的對象相關聯 。最好是基礎的模型與子腳本（也可能有第二個子腳本）相關聯。 有關更多信息，請參考以編程方式 進入 對象部分。 \n In order for models to be easily combined (i.e. built on top of each other) without any additional modification, it is important to consider what role the model will be playing: will it be dynamically simulated? Will it be attached to other models, or will it accept other models attached to it? The answer to those questions will allow you to select the best object type to work as a model base. Refer to the\xa0 section on designing dynamic simulations \xa0 for more information. \n 為了使模型易於組合（即彼此構建）而無需進行任何其他修改，重要的是要 考 慮模型將扮演什麼角色：可以動態模擬嗎？ 它會被附加到其他型號，還是會接受其他附加模型？   這些問題的答案將使您能夠選擇最佳的對像類型作為模型基礎。  有關更多信息，請參考設計動態仿真部分。 \n Copy and pasting a model behaves exactly like saving the model, then loading it (using however a memory buffer instead of the disk space). Models can be copied from one scene to another like any other object. Model files ("*.ttm"-files) also support drag-and-drop operations between the explorer window and the application window. Model files can also be double-clicked, in which case they will launch the CoppeliaSim application and be loaded into a default scene. \n 複製和粘貼模型的行為其實很像是在保存模型，然後加載 （完全使用內存緩衝區而不是磁盤空間）。 可以像其他任何對像一樣將模型從一個場景複製到另一個場景。  模型文件（“ * .ttm”文件）還支持資源管理器窗口和應用程序窗口之間的拖放操作。 還可以雙擊模型文件，在這種情況下，它們將啟動CoppeliaSim應用程序並加載到默認場景中。 \n The properties of a model can be individually adjusted in the \xa0 model dialog . \n 可以在模型對話框中單獨調整模型的屬性。 \n Model dialog(模型文字框) \n The properties of a model can be individually adjusted in the model dialog. It can be opened with a double-click on a model icon in the \xa0 scene hierarchy : \n 可以在模型對話框中單獨調整模型的屬性。 可以雙擊場景層次中的模型圖標來打開它： \n \n Some of above objects can have special properties allowing other objects or \xa0 calculation modules \xa0 to interact with them. Objects can be: \n 以上某些對象可以具有特殊的屬性，從而允許其他對像或計算模塊與它們進行交互。對象可以是： \n \n Collidable : collidable objects can be tested for \xa0 collision \xa0 against other collidable objects. \n Measurable : measurable objects can have the \xa0 minimum distance \xa0 between them and other measurable objects calculated. \n Detectable : detectable objects can be detected by \xa0 proximity sensors . \n Renderable : renderable objects can be \xa0 seen \xa0 or \xa0 detected \xa0 by \xa0 vision sensors . \n Viewable : viewable objects can be \xa0 looked through , \xa0 looked at , or their image content can be visualized in views. Refer to the \xa0 pages and views-section \xa0 for more information \n \n \n 可碰撞的： 可以測試可碰撞的物體與其他可碰撞物體的碰撞。 \n 可測量的： 可測量的對象與所計算的其他可測量對象之間的距離最小。 \n 可檢測的： 可檢測的物體 可以被接近傳感器檢測到。 \n 可渲染： 視覺傳感器可以看到或檢測可渲染對象 。 (渲染的意思:在我們假象的三维空間中，但是我們要在二维的顯示器中看到他，我們就稱之為把三角形從三维空間渲染到二维空間中 。) \n 可視對象： 可以查看，查看可視對象，或者可以在視圖中可視化其圖像內容。請參閱頁面和視圖部分以獲取更多信息 \n \n \n \n Select model thumbnail : when saving a model, a dialog pops open asking for a model thumbnail (that will be displayed in the \xa0 model browser ). If however you wish to save a thumbnail of your model in a different configuration (e.g. you wish to save a model of a snake robot in straight configuration, but you want the thumbnail to visualize the snake robot in a bent configuration), then you can specify the thumbnail here. \n \n 選擇模型縮略圖： 保存模型時，會彈出一個對話框，要求您提供模型縮略圖（將在模型瀏覽器中顯示）。但是，如果 您希望以其他配置保存模型的縮略圖（例如，希望以直線配置保存蛇形機器人的模型，但是希望縮略圖以彎曲的形態可視化蛇形機器人），則可以在此處指定縮略圖。 \n \n Override properties : here you can disable (override) specific properties for the whole model (i.e. for all objects in the model hierarchy tree). This is convenient to quickly disable a model that takes too much calculation time for instance. See also the sections on \xa0 collidable objects , \xa0 measurable objects , \xa0 renderable objects \xa0 and \xa0 detectable objects , and the \xa0 sim.setModelProperty API function . \n \n 覆蓋屬性： 您可以在此處為整個模型（即模型層次結構樹中的所有對象）禁用（覆蓋）特定屬性。例如，這可以方便地快速禁用需要太多計算模型的時間。 另請參見有關可碰撞對象，可測量對象，可呈現對象和可檢測對象的部分，以及sim.setModelProperty API函數。 \n \n Model content acknowledgments/Info : information related to a model. It is always good practice to acknowledge the original author of a model, or imported mesh. When a model that contains acknowledgment information is opened, it will automatically display that information. \n \n 模型內容確認/信息： 與模型有關的信息。  確認模型的原始作者或導入的網格物體始終是一種好習慣。 當包含確認信息的模型打開時，它將自動顯示該信息。 \n', 'tags': '', 'url': 'Scenes and models(場景和模型).html'}, {'title': 'Environment(環境)', 'text': "The environment in CoppeliaSim defines properties and parameters that are part of a\xa0 scene , but that are not \xa0 scene objects . Environment properties and parameters are not saved when a \xa0 model \xa0 is saved, but only when a scene is saved. \n CoppeliaSim中的環境定義了屬於場景但不屬於場景對象的屬性和參數 。   保存模型時，沒辦法保存環境屬性和參數，但只有在保存場景時可以保存。 \n An environment defines following properties and parameters: \n 環境定義以下屬性和參數： \n \n \n Background colors. \n Fog parameters. Fog parameters are not directly interacting with scene objects, except with \xa0 cameras \xa0 or \xa0 vision sensors \xa0 if the corresponding option was selected. \n Ambient light \n Scene creation information \n Additional settings \n \n \n 背景顏色。 \n 霧參數。 除已選擇相應選項的攝像機或視覺傳感器外，霧參數不會直接與場景對象交互。 \n 環境光 \n 場景創建信息 \n 其他設置 \n \n \n \n Environment dialog(環境文字框) \n The environment dialog can be accessed with [Menu bar --> Tools --> Environment] or by double-clicking following icon in the \xa0 scene hierarchy : \n 可以使用 [菜單欄->工具->環境] 或通過雙擊場景階層結構中的以下圖標來打開環境對話框： \n \n \n Background (up / down) : allows adjusting the background color of a scene. The up component corresponds to the upper part of the screen (sky), the down component corresponds to the lower part of the screen. The background colors are only visible when the fog functionality is disabled. \n \n 背景（上/下）： 允許調整場景的背景色。 向上部分對應於屏幕的上部（天空），向下部分對應於 屏幕的下部。僅當禁用霧功能時，背景色才可見。 \n \n Ambient light : allows adjusting the ambient light of a \xa0 scene . The ambient light can be seen as the minimal light of a scene, it illuminates an object in the exact same way from all directions. See the \xa0 section about lights \xa0 for more details about illumination of a scene. \n \n 環境光： 可以調整場景的環境光。 可以將環境光視為場景的最小光，它 從各個方向以完全相同的方式照亮對象。 有關場景照明的更多詳細信息，請參見關於燈光的部分。 \n \n Adjust fog parameters : allows to adjust various fog parameters. \n \n 調整霧參數：允許調整各種霧參數。 \n \n Maximum triangle size (absolute) : this item will not affect the visual appearance of \xa0 shapes . It will however affect the execution speed of most CoppeliaSim \xa0 calculation modules . When performing \xa0 minimum distance calculations \xa0 for instance, between two \xa0 entities , execution will generally be faster if both entities are composed by similar-sized triangles. The maximum triangle size value specifies how the internal representation of a \xa0 shape \xa0 is handled (i.e. how elaborate the shape's calculation structure is). Small sizes will increase the preprocessing time, but generally the simulation execution speed will be increased at the same time. This value sets the overall maximum triangle size, as an absolute value. See also next item and the \xa0 reduce triangle size -item in the \xa0 triangle edit mode . \n \n 最大三角形尺寸（絕對值）： 此項不會影響形狀的外觀。但是，它將 影響大多數CoppeliaSim計算模塊的執行速度。 例如， 在兩個實體之間執行最小距離計算時，如果兩個實體都由大小相似的三角形組成，則執行速度通常會更快。最大三角形尺寸值指定如何處理形狀的內部表示形式（即，形狀的計算結構的詳細程度）。小尺寸將增加預處理時間，但是通常仿真執行速度會同時提高。 此值將整體最大三角形大小設置為絕對值。另請參見下一項和在三角形編輯模式下的縮小三角形尺寸項目。 \n \n Minimum triangle size (relative) : similar to previous item, but this item helps avoiding creating too large calculation structures that might potentially take very long. This value sets the minimum triangle size, as a relative value (relative to a given object's largest dimension). \n \n 最小三角形尺寸（相對）： 與上一個項目相似，但該項目有助於避免創建太大的計算結構 ，而這可能會花費很長時間。 此值將最小三角形尺寸設置為相對值（相對於給定對象的最大尺寸）。 \n \n Save operation also saves existing calculation structures : for \xa0 distance calculations , \xa0 collision detections , etc. a data structure is computed at the beginning of a simulation (preprocessing), or the first time a \xa0 shape \xa0 is involves in such calculations, in order to speed-up calculations. Calculation of that data structure might be time consuming, so the user can chose to save it together with the \xa0 scene \xa0 or \xa0 model . However one has to be aware that the additional information that will be saved is large and will result in larger files (sometimes twice as large or more). \n \n 保存操作還會保存現有的計算結構： 用於距離計算，碰撞檢測等。 在模擬（預處理）開始時或第一次涉及形狀以加快速度時，會計算數據結構計算。計算該數據結構可能很耗時，因此用戶可以選擇將其與場景或模型一起保存。 但是，必須注意，將要保存的附加信息很大，並且會導致文件更大（有時是兩倍或更多）。 \n \n Shape textures disabled : if selected, then all \xa0 textures \xa0 applied to shapes will be disabled. \n \n 禁用形狀紋理： 如果選中，則將禁用應用於形狀的所有紋理。 \n \n Lock scene after next scene save : select this item if you want to lock your scene from edition/modification, script content viewing and resource export. After next scene save operation, the scene will be locked. Make sure you have saved the same scene in an unlocked state if you want to be able to modify it at a later time. \n \n 下一個場景保存後鎖定場景： 如果要從版本/修改，腳本內容查看和資源導出中鎖定場景，請選擇此項目。下一個場景保存操作後，場景將被鎖定。 如果希望以後可以修改同一場景，請確保已將其保存為未鎖定狀態。 \n \n Extension string : a string that describes additional environment properties, mainly used by extension plugins (see also the \xa0 sim.getExtensionString \xa0 API function). \n \n 擴展字符串： 描述附加環境屬性的字符串，主要由擴展插件使用 （另請參見sim.getExtensionString API函數）。 \n \n Clean-up object names : allows putting some order into object names with a hash tag. This is not necessary, but might be convenient to reduce the suffix numbers after the hash tags. \n \n 清理對象名稱： 允許使用主題標籤將一些順序放入對象名稱中 。 這不是必需的，但是可以方便地減主題標記後的後綴數。 \n \n Clean-up ghosts : removes all ghost objects a scene might contain. Refer also to the \xa0 ghost recording functionality . \n \n 清理重影： 刪除場景中可能包含的所有重影對象。 另請參閱幻像錄製功能。 \n \n Scene content acknowledgements / Info : information related to a scene. It is always good practice to acknowledge the original author of a scene, \xa0 model , or imported mesh. When a scene that contains acknowledgment information is opened, it will automatically display that information. \n \n 場景內容確認/信息： 與場景相關的信息。 最好先確認場景，模型或導入的網格的原始作者。當一個包含確認信息的場景被打開時，它將自動顯示該信息。 \n", 'tags': '', 'url': 'Environment(環境).html'}, {'title': 'Entities(實體)', 'text': 'An entity is a term that refers to a \xa0 scene object \xa0 or a \xa0 collection . Following figure illustrates the relationship between scene objects, collections and entities: \n 實體是指場景對像或集合的術語。  下圖說明了場景對象，集合和實體之間的關係： \n \n Scene objects(場景對象) \n The main elements in CoppeliaSim that are used for building a simulation\xa0 scene \xa0are scene objects (objects in short). Objects are visible in the\xa0 scene hierarchy \xa0and in the scene \xa0view . In the scene view, objects have a three dimensional representation as illustrated in following figure: \n CoppeliaSim中用於構建模擬場景的主要元素是場景對象（簡稱對象）。 對像在場景階層結構和場景視圖中可見。  在場景視圖中，對象具有三維表示，如下圖所示： \n \n Following list gives a brief functional description of each object type: \n \n \n Shapes : a shape is a rigid mesh that is composed of triangular faces. \n Joints : a joint object is a joint or actuator. Four types are supported: revolute joints, prismatic joints, screws and spherical joints. \n Graphs : a graph is used to record and visualize simulation data. \n Dummies : a dummy is a point with orientation. Dummies are multipurpose objects that can have many different applications. \n Proximity sensors : a proximity sensor detects objects in a geometrically exact fashion within its detection volume. CoppeliaSim supports pyramid-, cylinder-, disk-, cone- and ray-type proximity sensors. \n Vision sensors : a vision sensor is a camera-type sensor, reacting to light, colors and images. \n Force sensors : a force sensor is an object able to measure forces and torques that are applied to it. It also has the ability to \xa0 break \xa0 if a given threashold is overshot. \n Cameras : a camera is an object that allows \xa0 seeing \xa0 the simulation scene from various view points. \n Lights : a light is an object that allows illuminating the simulation scene. \n Paths : a path is an object that defines a path or trajectory in space. It can be used for various purposes, also as a customized joint or actuator. \n OC trees : an OC tree is a spacial partitioning data structure made up by voxels. \n Point clouds : a point cloud is an OC tree structure that contains points. \n \n \n 形狀： 形狀是由三角形面組成的剛性網格。 \n 軸節： 軸節對像是關節或執行器。支持四種類型：旋轉接頭，棱柱接頭，螺釘和球形接頭。 \n 圖形： 圖形用於記錄和可視化模擬數據。 \n 用來填充的無用物件： 無用物件 是具有定向的點。 無用物件是可以具有許多不同應用程序的多用途對象。 \n 鄰近傳感器： 鄰近傳感器以幾何精確的方式在其檢測範圍內檢測物體 。 CoppeliaSim支持金字塔型，圓柱型，圓盤型，圓錐型和射線型接近傳感器。 \n 視覺傳感器： 視覺傳感器是一種相機型傳感器，對光線，顏色和圖像有反應。 \n 力傳感器： 力傳感器是能夠測量施加到其上的力和扭矩的對象。 如果給定的閾值被超出，它也具有打破的能力。 \n 攝像機： 攝像機是一個對象，可以從各個角度查看模擬場景。 \n 燈光： 燈光是一個可以照亮模擬場景的對象。 \n 路徑： 路徑是在空間中定義路徑或軌蹟的對象。它可以用於各種目的，也可以用作定制的接頭或執行器。 \n 八元樹： 八元樹是由體素組成的空間分區數據結構。 \n 點雲： 點雲是包含點的 八元 樹結構。 \n \n \n Some of above objects can have special properties allowing other objects or \xa0 calculation modules \xa0 to interact with them. Objects can be: \n 以上某些對象可以具有特殊的屬性，從而允許其他對像或計算模塊與它們進行交互。對象可以是： \n \n Collidable : collidable objects can be tested for \xa0 collision \xa0 against other collidable objects. \n Measurable : measurable objects can have the \xa0 minimum distance \xa0 between them and other measurable objects calculated. \n Detectable : detectable objects can be detected by \xa0 proximity sensors . \n Renderable : renderable objects can be \xa0 seen \xa0 or \xa0 detected \xa0 by \xa0 vision sensors . \n Viewable : viewable objects can be \xa0 looked through , \xa0 looked at , or their image content can be visualized in views. Refer to the \xa0 pages and views-section \xa0 for more information \n 可碰撞的： 可以測試可碰撞的物體與其他可碰撞物體的碰撞。 \n 可測量的： 可測量的對象與所計算的其他可測量對象之間的距離最小。 \n 可檢測的： 可檢測的物體 可以被接近傳感器檢測到。 \n 可渲染： 視覺傳感器可以看到或檢測可渲染對象 。 (渲染的意思:在我們假象的三维空間中，但是我們要在二维的顯示器中看到他，我們就稱之為把三角形從三维空間渲染到二维空間中 。) \n 可視對象： 可以查看，查看可視對象，或者可以在視圖中可視化其圖像內容。請參閱頁面和視圖部分以獲取更多信息 \n \n \n Each object has a position and orientation within the simulation scene. We refer to an object\'s position and orientation as configuration of the object. Objects can be attached to other objects (or built on top of each other). If object A is built on top of object B, then object B is the parent and object A is the child. To create a parent-child relationships between object B and object A, select object A, then select object B (the selection order is important). Then select [Menu bar --> Edit --> Make last selected object parent]. Following figure illustrates this operation: \n 每個對像在模擬場景中都有一個位置和方向。 我們將對象的位置和方向稱為對象的配置。  可以將對象附加到其他對象（或建立在彼此之上）。 如果對象A建立在對象B的頂部，則對象B是父對象，而對象A是子對象。 要在對象B和對象A之間創建父子關係，請選擇對象A，然後選擇對象B（選擇順序很重要）。 然後選擇[菜單欄->編輯->將最後選擇的對象設為父對象]。  下圖說明了此操作： \n \n Alternatively, you can drag and drop an object onto another one in the \xa0 scene hierarchy \xa0 to obtain a similar result. Notice that object A\'s configuration was not changed (both objects kept their respective configuration). However, looking at the scene hierarchy, you can see that object A became child of object B. If you now move object B, object A will automatically follow, since object A is attached to object B. Object A can be detached by selecting it, then selecting [Menu bar --> Edit --> Make selected object(s) orphan]. Doing so will detach object A without changing its configuration. Alternatively, you can drag and drop an object onto the world icon to obtain a similar result. \n 或者，您可以將一個對象拖放到場景階層結構中的另一個對像上，以獲得相似的結果。(將對象A加入為對象B的子對象)。 請注意，對象A的配置未更改（兩個對像都保留了各自的配置）。但是，查看場景階層結構，您可以看到對象A成為對象B的子對象。如果現在移動對象B，則對象A將自動跟隨，因為對象A已附加到對象B。可以通過選擇對象A來分離對象A。  然後選擇[菜單欄->編輯->使所選對象成為孤立對象]。這樣做將分離對象A而不會更改其配置。或者，您可以將一個對象拖放到上層圖標上以獲得類似的結果。 \n \n \n \n (1)\xa0 \xa0Scene object properties(場景對象屬性) \n The \xa0 scene object \xa0 properties dialog is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the \xa0 scene hierarchy , or with a click on its \xa0 toolbar \xa0 button: \n 場景對象屬性對話框位於 [菜單欄->工具->場景對象屬性] 。 您也可以通過 雙擊場景階層結構中的對像圖標或單擊其工具欄按鈕來打開 對話框： \n \n The scene object properties dialog displays properties related to objects (i.e. \xa0 scene objects ). The dialog is context sensitive and its content will mainly depend on the scene object selection state: only the properties of the last selected object will be displayed. Those properties are divided into 2 parts: \n 場景對象屬性對話框顯示與對象（即場景對象）相關的屬性。  該對話框是上下文相關的，其 內容將主要取決於場景對象的選擇狀態：僅顯示最後選擇的對象的屬性。  這些屬性分為兩部分： \n \n \n \n Object-type specific properties : properties specific to the selected object type. See further below for details. \n Object common properties : properties common to all object types. \n \n \n 特定於對像類型的屬性： 特定於所選對像 類型的屬性。 詳情請參見下文。 \n 對象通用屬性： 所有對像 類型 通用的屬性。 \n \n \n 2 buttons in the upper part of the dialog allow selecting the desired type of properties to display. If the object selection is empty, then all dialog items will be inactive. \n 對話框上部的2個按鈕允許選擇要顯示的所需屬性類型 。  如果對象選擇為空，則所有對話框項都將處於非活動狀態。 \n \n Object common properties(場景對象通用屬性) \n The object common properties dialog is part of the\xa0 scene object properties\xa0 dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the\xa0 scene hierarchy , or with a click on its\xa0 toolbar \xa0button: \n 對象公共屬性對話框是場景對象屬性對話框的一部分，位於 [菜單欄->工具->場景對象屬性] 。 您也可以通過 雙擊場景階層結構中的對像圖標或單擊其工具欄按鈕 來打開對話框： \n \n n the scene object properties dialog, click the \xa0 Common \xa0 button to display the object common properties dialog. The dialog displays the settings and parameters of the last selected \xa0 object . If no object is selected, the dialog is inactive. If more than one object is selected, then some parameters can be copied from the last selected object to the other selected objects ( Apply to selection -buttons): \n 在場景對象屬性對話框中，單擊“通用”按鈕以顯示對象通用屬性對話框。  該對話框顯示最後選擇的對象的設置和參數。 如果未選擇任何對象，則該對話框處於非活動狀態。  如果選擇了多個對象，則可以將某些參數從上一個選定對象複製到其他選定對象 （適用於選擇按鈕）： \n \n \n \n Selectable : indicates whether the object can be selected in the scene. Objects can always be selected in the \xa0 scene hierarchy . Refer also to the \xa0 sim.setObjectProperty \xa0 function. \n \n 可選： 指示是否可以在場景中選擇對象。始終可以在場景階層中選擇對象。 另請參閱sim.setObjectProperty函數。 \n \n Invisible during selection : when enabled, then the object will be invisible for the selection process (i.e. you will be able to select \xa0 through \xa0 the object). \n \n 選擇期間不可見： 啟用該選項後，對象將在選擇過程中不可見（即， 您將可以通過對象進行其他對象選擇 ）。 \n \n Ignored by depth pass : when enabled, then the object will be ignored during the depth rendering pass. The depth rendering pass is used to correctly position the red sphere for camera movements. \n \n 被深度傳遞忽略： 啟用時， 在深度渲染傳遞過程中將忽略該對象。深度渲染傳遞用於正確定位紅色球體以進行相機移動。 \n \n Select base of model instead : if enabled, then selecting the object in the scene will select its first parented object marked as \xa0 object is model base \xa0 instead (see further down). This property is convenient when protecting a model from faulty manipulations, allowing it to be manipulated as a single entity together with other objects. Refer to the \xa0 section on models \xa0 and also to the \xa0 sim.setObjectProperty \xa0 function. \n \n 替代選擇模型基礎： 如果啟用，則在場景中選擇對象將選擇其第一個父對象，標記為“對像是模型基礎” （請參見下一節）。 當保護模型免受錯誤操縱時，此屬性很方便，允許將其與其他對像一起作為單個實體進行操縱。 請參考有關模型的部分以及sim.setObjectProperty函數。 \n \n Ignored by model bounding box : when selected, and the object is part of a \xa0 model , then the model bounding box (i.e. model selection bounding box) will not encompass that object. This is useful for invisible objects that might make the model bounding box appear too big. This property has no functional effect. Refer also to the \xa0 sim.setObjectProperty \xa0 function. \n \n 被模型邊界框忽略： 選中該對象並且該對像是模型的一部分時，模型邊界框（即模型選擇邊界框）將不包含該對象。 這對於可能會使模型邊界框顯得太大的不可見對像很有用。此屬性沒有功能作用。另請參閱sim.setObjectProperty函數。 \n \n Ignored for view-fitting : objects with this item selected will not be taken into account when fitting a scene to a view while no object is selected. Usually floors and similar will be tagged as such. Refer also to the \xa0 view fitting toolbar button \xa0 and to the \xa0 sim.cameraFitToView api function . \n \n 忽略視圖擬合： 在未選擇任何對象的情況下將場景擬合到視圖時，將不考慮選擇此項目的對象。 通常地板和類似物會被這樣標記。另請參閱適合視圖的工具欄按鈕和sim.cameraFitToView api函數。 \n \n Cannot be deleted during simul. : when enabled, then the object will ignore a deletion operation when a simulation is running (deletion will however still work when triggered via code). \n \n 無法在模擬過程中刪除： 啟用後，對象將在模擬運行時忽略刪除操作 （但是，通過代碼觸發後，刪除仍然可以進行）。 \n \n Cannot be deleted : when enabled, then the object will ignore a deletion operation (deletion will however still work when triggered via code). \n \n 無法刪除： 啟用後，該對象將忽略刪除操作 （但是，通過代碼觸發後，刪除仍將起作用）。 \n \n Extension string :  a string that describes additional object properties, mainly used by extension plugins (see also the \xa0 sim.getExtensionString \xa0 API function). \n \n 擴展字符串： 描述附加對象屬性的字符串，主要由擴展插件使用 （另請參見sim.getExtensionString API函數）。 \n \n Camera visibility layers : each object in CoppeliaSim can be assigned to one or several visibility layers. If there is at least one visibility layer that matches the \xa0 layer selection dialog \xa0 layers, then the object will be visible when seen from a camera. By default, a \xa0 shape \xa0 is assigned to the first layer, a \xa0 joint \xa0 to the second layer, a \xa0 dummy \xa0 to the third layer, etc. \n \n 攝像機可見性層： 可以將CoppeliaSim中的每個對象分配給一個或多個可見性層。如果至少有一個與圖層選擇對話框圖層匹配的可見性圖層，則從攝像機看時該對象將可見。 默認情況下，將形狀分配給第一層，將關節分配給第二層，將虛擬對象分配給第三層，等等。 \n \n Can be seen by : allows to specify a \xa0 camera \xa0 or \xa0 vision sensor \xa0 (or a \xa0 collection \xa0 containing cameras or vision sensors) that will be the only one able to see the object. \n \n 可以通過以下方式看到： 允許指定將是唯一能夠看到對象的攝像機或視覺傳感器 （或包含攝像機或視覺傳感器的集合）。 \n \n Collidable : allows enabling or disabling \xa0 collision detection \xa0 capability for the selected \xa0 collidable object . \n \n 可碰撞： 允許為選定的可碰撞對象啟用或禁用碰撞檢測功能。 \n \n Measurable : allows enabling or disabling \xa0 minimum distance calculation \xa0 capability for the selected \xa0 measurable object . \n \n 可測量的： 允許啟用或禁用所選可測量對象的最小距離計算功能。 \n \n Detectable : allows enabling or disabling \xa0 proximity sensor \xa0 detection capability for the selected \xa0 detectable object . Clicking \xa0 details \xa0 allows you to edit the detectable details. \n \n 可檢測： 允許為選定的可檢測對象啟用或禁用接近傳感器檢測功能。 單擊詳細信息可讓您編輯可檢測的詳細信息。 \n \n Renderable : allows enabling or disabling the \xa0 vision sensor \xa0 detection capability for the selected \xa0 renderable object . \n \n 可渲染： 允許為選定的可渲染對象啟用或禁用視覺傳感器檢測功能。 \n \n Object is model base : indicates whether the object should act as the base of a \xa0 model . An object flagged as \xa0 base of model \xa0 has special properties (e.g. saving or copying the object will also automatically save/copy all its children and children\'s children, etc.). Additionally, when such an object is selected, the selection bounding box is displayed as thick stippled lines, encompassing the whole model. Refer to \xa0 models , and to the \xa0 select base of model instead \xa0 item above. \n \n 對像是模型的基礎： 指示對像是否應充當模型的基礎。標記為模型基礎的對象具有特殊屬性 （例如，保存或複制該對像還將自動保存/複製其所有子對像以及子對象的子對象等）。另外， 當選擇了此類對象時，選擇邊界框將顯示為點狀的粗線，包圍整個模型。 請參考模型，並參考上面的模型選擇模型。 \n \n Edit model properties : allows opening the \xa0 model dialog . \n \n 編輯模型屬性： 允許打開模型對話框。 \n \n Object / model can transfer or accept DNA : \xa0 when this feature is enabled for an object or a model, then it will share a same identifier with all of its copies. An Object or model can then transfer its DNA (i.e. copy an instance of itself) to all of its siblings (i.e. objects/models with the same identifier), via the transfer DNA \xa0 toolbar \xa0 button. Imagine having 100 same robots in your scene that you want to modify in a similar way: simply modify one of them, select it, then click the transfer DNA toolbar button. This item should almost always be checked for a model base (see further up), to facilitate model re-instanciation. \n \n 對象/模型可以轉移或接受DNA： 當為對像或模型啟用此功能時，它將與所有副本共享相同的標識符。 然後，對像或模型可以通過轉移DNA工具欄按鈕將其DNA （即復制其自身的實例） 轉移到其所有同級兄弟 （即具有相同標識符的對象/模型）。 想像一下，您要以類似的方式修改場景中的100個相同的機器人：只需修改其中一個，選擇它，然後單擊Transfer DNA工具欄按鈕。 幾乎應始終檢查該項目的模型基礎（請參閱後續部分），以促進模型的重新實例化。 \n \n \n Collection self-collision indicator : when performing collision (or minimum distance) calculations between two identical collections, CoppeliaSim will normally check all collection items against all other items in that collection. In some situation, such as a kinematic chain, one doesn\'t want to check consecutive links, since they might be constantly colliding at the interface. In that case, you can use the collection self-collision indicator: two items of a same collection will not be checked against each other if their indicator difference is exactly 1, as can be seen on following figure: \n \n 集合自我碰撞指示器： 在兩個相同的集合之間執行碰撞（或最小距離）計算時，CoppeliaSim通常會對照該集合中的所有其他項目檢查所有集合項目。 在某些情況下，例如運動鏈，一個人不想檢查連續的鏈接，因為它們可能在接口處不斷碰撞。 在這種情況下，您可以使用集合自衝突指標： 如果同一集合的兩個項目的指標差恰好為1，則不會相互檢查它們 ，如下圖所示： \n \n \n Scaling : objects or models can be scaled in a flexible way in CoppeliaSim. The size of an object or model, and all related properties are scaled appropriately (e.g. joint ranges, velocity settings, masses, etc.) so that the scaled object or model can normally continue to operate (but at a different scale). \n \n 縮放： 可以在CoppeliaSim中靈活地縮放對像或模型。 適當縮放對像或模型的大小以及所有相關屬性（例如關節範圍，速度設置，質量等） ，以便縮放後的對像或模型可以正常繼續運行（但以不同的比例）。 \n \n Assembling :  opens a dialog that allows to specify how the \xa0 assembling toolbar button \xa0 will handle the object during assembly (if objects are assembled in a different way than via the assembling toolbar button, then following settings will have no influence): \n \n 組裝： 打開一個對話框，該對話框可指定組裝期間工具欄按鈕如何處理對象 （如果對象的組裝方式與通過工具欄按鈕的組裝方式不同，則以下設置將沒有影響）： \n \n \n Required match values for parent : the object can be attached to another object (i.e. become another object\'s child), but only if one of the listed \xa0 required match values for parent \xa0 matches one of its new parent\'s \xa0 required match values for child \xa0 values. This feature is useful in order to set a fixture compatibility criteria (e.g. gripper A can only be attached with a robot that has a tooltip of type A). \n \n 母體的必需匹配值： 可以將對象附加到另一個對象（即成為另一個對象的子對象） ，但前提是列出的母體必需匹配值之一與其新母體的子項必需匹配值之一匹配。 此功能對於設置夾具兼容性標準很有用（例如，夾具A只能與工具提示類型為A的機器人連接）。 \n \n Required match values for child : the object can have another object attached to itself (i.e. become another object\'s parent), but only if one of its \xa0 required match values for child \xa0 matches one of its new child\'s \xa0 required match values for parent \xa0 values. This feature is useful in order to set a fixture compatibility criteria (e.g. gripper A can only be attached with a robot that has a tooltip of type A). \n \n 子項的必需匹配值： 該對象可以附加另一個對象（即成為另一個對象的母體） ，但前提是其子項的必需匹配值之一與其新子項的主值必需匹配值之一匹配。此功能對於設置夾具兼容性標準很有用（例如，夾具A只能與工具提示類型為A的機器人連接）。 (上述功能的相反操作) \n \n When assembling, a specific local transform. matrix will be applied : if checked, then the object won\'t stay in place when assembled: a specific transformation matrix will be used as its new local transformation matrix. By default that matrix is the identity matrix, but you can specify a specific matrix by clicking \xa0 Set matrix . This feature is useful in order to automatically position and orient an object correctly in relation to its new parent (e.g. in order to have a gripper automatically placed correctly at a robot\'s tooltip) \n \n \n 組裝時，進行特定的局部轉換。矩陣將被應用： 如果選中，則對像在組裝時不會停留在原位：特定的變換矩陣將用作其新的局部變換矩陣。 默認情況下，該矩陣是單位矩陣，但是您可以通過單擊設置矩陣來指定特定矩陣。 此功能對於自動相對於其新主對象正確定位和定向對像很有用（例如，為了使抓取器自動正確放置在機器人的工具提示上） \n The object selection order is important for assembly operations, i.e. first select the \xa0 to-become-child-object , then the \xa0 to-become-parent-object . If the selection order is wrong, or if the \xa0 to-become-parent-object \xa0 is not appropriate, then CoppeliaSim will try to guess what the real intention of the user was (e.g. by searching for an appropriate match in the \xa0 to-become-parent-object \'s descendents), if there is no ambiguity. \n 對象選擇順序對於組裝操作很重要，即首先選擇要成為子對象的對象，然後選擇要成為母體的對象 。 如果選擇順序有誤，或者如果成為母體的對像不合適，那麼CoppeliaSim將嘗試猜測用戶的真實意圖（例如，藉著尋找合適的匹配項在，成為母體對象的子對象的這件事上），如果沒有模糊的話。 \n \n \n \n Cameras(攝影機) \n \n Cameras are\xa0 viewable objects , which means that you can \xa0 look through \xa0 them and display a view of what they are \xa0 looking at . You can have as many cameras as needed in your \xa0 scene , each one of them offering a different \xa0 view \xa0 of the scene. Following shows an example of a scene containing several cameras: \n 相機是可見的對象，這意味著您可以瀏覽它們並顯示其所觀看內容的視圖。  您可以根據需要在場景中擁有任意數量的攝像機，每個攝像機都提供不同的場景視圖。 以下是一個包含多個攝像機的場景示例： \n \n Make sure not to mix-up cameras with \xa0 vision sensors . Following are the main differences: \n 確保不要將 攝像機 與 視覺傳感器 混淆。 以下是 主要區別 ： \n \n \n A camera has no specific resolution (i.e. it adjusts automatically to the view size). A vision sensor has a fixed resolution. \n A camera\'s image content is not directly available via the \xa0 API \xa0 (but via a callback mechanism), and image processing not directly supported. A vision sensor\'s image content can be accessed via the API, and processed via the \xa0 vision callback functions . \n A camera generally requires less CPU time and operates faster than vision sensors. \n A camera can display all \xa0 object types . A vision sensor can only display \xa0 renderable objects . \n \n \n 相機沒有特定的分辨率（即，它會自動調整為視圖尺寸）。 視覺傳感器具有固定的分辨率。 \n 相機的圖像內容不能通過API直接獲得（而是通過回調機制獲得），並且 不直接支持圖像處理。   視覺傳感器的圖像內容可以通過API進行訪問，並通過視覺回調函數進行處理。 \n 攝像機通常比視覺傳感器需要更少的CPU時間並且運行得更快。 \n 攝像機可以顯示所有對像類型。  視覺傳感器只能顯示可渲染的對象。 \n \n \n A camera can be added to the scene with [Menu bar --> Add --> Camera]. However adding a camera in this way will add the \xa0 object \xa0 in a default position and orientation. It is a better practice to add cameras by right-clicking on a specific view of a scene and selecting [Popup menu --> Add --> Camera]. This will add the object just in front of the current view. The added camera is automatically selected and you can then \xa0 look through it \xa0 with [Popup menu --> View --> Associate view with selected camera]. For this to work you will have to make sure the popup menu is activated on a view. When a view is created but not yet associated with a viewable object, the [Popup menu --> Add --> Camera] command will add a camera and directly associate it with the view (i.e. \xa0 look through it ). A camera can be associated with any number of views. \n 可以使用[菜單欄->添加->攝像機]將攝像機添加到場景中。 但是，以這種方式添加相機會將對象添加到默認位置和方向。  最好通過右鍵單擊場景的特定視圖並選擇[彈出菜單->添加->攝像機]來添加攝像機。 這會將對象添加到當前視圖的前面 。 添加的攝像機會自動選擇，然後您可以使用[彈出菜單->視圖->將視圖與所選攝像機關聯]進行瀏覽。  為此，您必須確保在視圖上激活了彈出菜單。 創建視圖但尚未與可見對象關聯時，[彈出菜單->添加->攝像機]命令將添加攝像機並將其直接與視圖關聯（即瀏覽）。 攝像機可以與任意數量的視圖關聯。 \n Alternatively you can also associate a view with a camera by activating following popup in a view: [Popup menu --> View --> View selector..]. This will allow you to select the desired camera view from a preview window. When a camera is associated with a view, it can be manipulated with the mouse with following toolbar buttons: \n 或者， 您還可以通過激活視圖中的以下彈出窗口來將視圖與攝像機關聯：[彈出菜單->視圖->視圖選擇器..]。 這將允許您從預覽窗口中選擇所需的攝像機視圖。  將相機與視圖關聯時，可以使用以下工具欄按鈕用鼠標對其進行操作： \n \n \n \n Camera angle button : allows adjusting the perspective projection angle of a camera view (when in perspective projection mode), or allows adjusting the view size of a camera view (when in orthogonal projection mode). \n Fit-to-view button : adjusts the camera of the view that has the focus in order to nicely frame all selected objects, or the entire scene if no object is selected. \n \n \n 攝像機角度按鈕： 允許調整攝像機視圖的透視投影角度（在透視投影模式下），或者 允許調整攝像機視圖的視圖尺寸 （在正交投影模式下）。 \n 適合視圖的按鈕： 調整具有焦點的視圖的攝像機， 以很好地構圖所有選定的對象，或者如果沒有選擇任何對象，則對整個場景進行構圖。 \n \n When the camera shift button is activated, it is very easy to navigate in the scene to any desired position and orientation using: (1) the left mouse button for shifting perpendicular to the view direction, (2) the mouse wheel for shifting along the view direction, and (3) the right mouse button for rotating about the clicked point: \n 激活相機移位按鈕後，使用以下方法很容易在場景中導航到任何所需的位置和方向： （1）鼠標左鍵用於垂直於視圖方向的移動；（2）鼠標滾輪用於沿視圖的移動 查看方向，以及（3）鼠標右鍵圍繞點擊點旋轉： \n \n Cameras can automatically track objects (i.e. follow them as they move) by selecting the object to track, then selecting in the appropriate view [Popup menu --> View --> Track selected object]. A tracking camera will keep its position, but automatically adjust its viewing direction in order to always keep the object to track in its view field. This is different from having a camera attached to that object through a parent-child relationship. \n 相機可以通過選擇要跟踪的對象，然後在適當的視圖中選擇[彈出菜單->視圖->跟踪所選對象]，自動跟踪對象（即，跟隨它們移動）。   跟踪攝像機將保持其位置，但會自動調整其查看方向，以始終使對像在其視野中進行跟踪。 這與通過父子關係將攝像機連接到該對像不同。 \n Camera properties(攝影機屬性) \n The camera properties are part of the \xa0 scene object properties \xa0 dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the \xa0 scene hierarchy , or with a click on its \xa0 toolbar \xa0 button: \n 攝像機屬性是場景對象屬性對話框的一部分，該對話框位於 [菜單欄->工具->場景對象屬性] 。 您 也可以通過雙擊場景層次結構中的對像圖標 或單擊其工具欄按鈕來打開對話框： \n \n In the scene object properties dialog, click the \xa0 Camera \xa0 button to display the camera dialog (the \xa0 Camera \xa0 button only appears if the last selection is a \xa0 camera ). The dialog displays the settings and parameters of the last selected camera. If more than one camera is selected, then some parameters can be copied from the last selected camera to the other selected cameras ( Apply to selection -buttons): \n 在場景對象屬性對話框中，單擊“攝影機”按鈕以顯示攝影機對話框（“攝影機”按鈕僅在最後選擇的是攝影機時出現）。  該對話框顯示最後選擇的攝像機的設置和參數。 如果選擇了多個攝像機，則可以將某些參數從最後選擇的攝像機複製到其他選定的攝像機 （適用於選擇按鈕）： \n \n \n \n Perspective angle : the perspective projection angle (or \xa0 opening \xa0 angle) of a camera. The effect of this parameter can only be seen if the associated \xa0 view \xa0 is in perspective projection mode. \n \n 透視角： 攝像機的透視投影角 （或打開角度）。僅當關聯的視圖處於透視投影模式時，才能看到此參數的效果。 \n \n Orthographic size : the orthographic projection size (or view size) of a camera. The effect of this parameter can only be seen if the associated view is in orthographic projection mode. \n \n 正射影像尺寸： 相機的正射投影尺寸（或視圖尺寸） 。僅當關聯視圖處於正交投影模式時，才能看到此參數的效果。 \n \n Near / far clipping plane : distance from the camera origin point from which the camera starts / stops \xa0 seeing . If close / far objects should not be displayed, increase / reduce this value. These parameters are directly linked with the rendering precision, especially when an associated view is in perspective projection mode, then you should always be careful not to have a too big gap between the far and near clipping planes, otherwise you might experience some visual artifacts known as \xa0 z-fighting \xa0 (when surfaces or pixels farther away appear to overlap surfaces/pixels closer to the camera). \n \n 遠/近剪切平面： 距攝像機開始/停止觀察的攝像機原點的距離。 如果不應顯示近/遠對象，請增大/減小此值。 這些參數與渲染精度直接相關，尤其是當關聯的視圖處於透視投影模式時，那麼應始終注意，遠裁剪面和近裁剪面之間的距離不要太大，否則可能會遇到一些已知的視覺偽像z爭鬥（當較遠的表面或像素看起來與更靠近相機的表面/像素重疊時）。 \n \n Render mode : the render mode of the camera. \n \n 渲染模式： 攝像機的渲染模式。 \n \n Tracked object : object to be tracked by the camera. Tracking an object will not influence the camera\'s position, only its orientation will be automatically adjusted in order to \xa0 follow \xa0 the tracked object. \n \n 跟踪對象： 攝像機跟踪的對象。 跟踪對像不會影響相機的位置，僅會自動調整其方向以跟隨跟踪的對象。 \n \n Show fog if enabled : if disabled, then this camera won\'t see any fog if fog is enabled. Also refer to the \xa0 environment dialog . \n \n 如果啟用，則顯示霧： 如果禁用，則啟用霧後，本相機將看不到任何霧 。 另請參閱環境對話框。 \n \n Keep head always up : if enabled, the camera will always try to \xa0 keep its head up , i.e. keep the camera\'s y-axis in a vertical plane. \n \n 始終保持頭部抬起： 啟用該選項後，相機將始終保持抬頭 ，即，將相機的y軸保持在垂直平面上。 \n \n Use local lights : if enabled, then only local lights parented with this camera (i.e. built on top of this camera) will be activated when displaying this camera\'s image content. \xa0 Lights \xa0 can be made local in the \xa0 light properties . \n \n 使用局部照明： 如果啟用，則在顯示此照相機的圖像內容時，只會激活與此照相機為主（即內置在此照相機頂部）的局部照明。 可以在光源屬性中使光源局部化。 \n \n Allow picking : allows you to enable/disable object picking (i.e. click to select an object) \n \n 允許拾取： 允許您啟用/禁用對象拾取（即單擊以選擇一個對象） \n \n Use parent as camera manipulation proxy : if enabled, then the camera manipulation toolbar buttons will not affect the camera\'s position directly, but instead will affect the camera\'s parent object. This option is useful if you wish to have several cameras linked to each other (e.g. the default scene in CoppeliaSim has 3 cameras arranged orthogonally to each other. If one is moved, the two others will follow) \n \n 運用母體關係當作攝像機的操作代理： 如果啟用，則攝像機操作工具欄按鈕將不會直接影響攝像機的位置，而是會間接影響攝像機的母體關係對象。 如果您希望將多個攝像機彼此鏈接（例如，CoppeliaSim中的默認場景具有3個彼此正交排列的攝像機，則此選項很有用。 如果移動一個攝像機，則另外兩個攝像機將跟隨 ） \n \n Along own X- / Y- / Z-axis : allows specifying which camera translation movements are allowed. \n \n 沿自己的X / Y / Z軸： 允許指定允許攝像機的平移運動。 \n \n Full rotation : if selected, then the camera is not limited in angular movements. \n \n 全旋轉： 如果選擇此項，則 攝像機不受角度運動的限制。 \n \n Tilting : if selected, then the camera can be tilted with the corresponding toolbar button. \n \n 傾斜： 如果選中，則可以使用相應的工具欄按鈕傾斜相機。 \n \n Object size : size of the camera. This parameter has only a visual effect and no functional meaning. \n \n 對象尺寸： 相機的尺寸。該參數僅具有視覺效果，沒有功能意義。 \n \n Adjust color A / B : allows adjusting a camera\'s casing colors. \n \n 調整顏色A / B： 可以調整相機的外殼顏色。 \n \n \n \n Shapes(形狀) \n Shapes are rigid mesh\xa0 objects \xa0 that are composed of triangular faces. They can be \xa0 imported , \xa0 exported \xa0 and \xa0 edited . They come in four different sub-types: \n 形狀是由三角形面組成的剛性網格物體。 可以導入，導出和編輯。  它們分為四種不同的子類型： \n \n \xa0 Simple random shape : can represent any mesh. It has one color and one set of visual attributes. Not optimised nor recommended for \xa0 dynamics collision response calculation \xa0 (since very slow and unstable). \n \n 簡單的隨機形狀： 可以代表任何網格。 它具有一種顏色和一組視覺屬性。  未優化，也 不建議用於動態碰撞響應計算（因為非常緩慢且不穩定）。 \n \n \xa0 Compound random shape : can represent any mesh. It has several colors and sets of visual attributes. Not optimised nor recommended for dynamics collision response calculation (since very slow and unstable). \n \n 複合隨機形狀： 可以代表任何網格。  它具有幾種顏色和一組視覺屬性。   未優化，也不建議用於動態碰撞響應計算（因為非常緩慢且不穩定）。 \n \n \xa0 Simple convex shape : represents a convex mesh with one color and one set of visual attributes. Optimized for dynamics collision response calculation (but pure shapes are recommended). \n \n 簡單凸形： 表示具有一種顏色和一組視覺屬性的凸網格。 針對動力學碰撞響應計算進行了優化（但建議使用純形狀）。 \n \n \xa0 Compound convex shape : represents a group of convex meshes with several colors and sets of visual attributes. Optimized for dynamics collision response calculation (but pure compound shapes are recommended). \n \n 複合凸形狀： 表示一組具有 多種顏色和一組視覺屬性 的凸網格。 針對動力學碰撞響應計算進行了優化（但建議使用純複合形狀）。 \n \n \xa0 Pure simple shape : represents a primitive shape (cuboid, cylinder or sphere (with additional variations depending on the used physics engine). A pure simple shape (or pure compound shape) is best suited for dynamics collision response calculation, since it will perform very fast and is stable. See the \xa0 dynamics module \xa0 section for more information. \n \n 純簡單形狀： 表示原始形狀 （長方體，圓柱體或球體（根據所使用的物理引擎的不同，可能會有其他變化）。 純簡單形狀（或純複合形狀）最適合於動力學碰撞響應計算，因為它的執行性能非常好 快速且穩定 ，請參閱動力學模塊部分以獲取更多信息。 \n \n \xa0 Pure compound shape : represents a group of primitive shapes (cuboid, cylinder or sphere). A pure compound shape (or pure simple shape) is best suited for dynamics collision response calculation, since it will perform very fast and is stable. See the \xa0 dynamics module \xa0 section for more information. \n \n 純複合形狀： 代表一組原始形狀（長方體，圓柱體或球體）。 純複合形狀（或純簡單形狀）最適合動力學碰撞響應計算，因為它執行起來非常快且穩定。 有關更多信息，請參見動力學模塊部分。 \n \n \xa0 Heightfield shape : can represent a terrain as a regular grid, where only the heights change. Heightfields can also be considered as pure simple shapes, and are optimized for dynamics collision response calculation. \n \n 高度場形狀： 可以將地形表示為規則的網格，僅高度會發生變化。  高度場也可以視為純簡單形狀，並針對動力學碰撞響應計算進行了優化 \n \n By default, all imported shapes are simple shapes. Two or more simple shapes or compound shapes can however be grouped ([Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]) or ungrouped ([Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]). Simple shapes can also be merged ([Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes] in which case the visual properties become same for all composing elements. A shape can also be divided ([Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]), depending on its configuration: the division algorithm will extract each distinct element of a shape. Two elements are distinct if they don\'t share any common edge. Refer also to the\xa0 model tutorial . which illustrates how to correctly import and prepare shapes for a simulation model. \n 默認情況下，所有導入的形狀均為簡單形狀。 但是，可以將兩個或更多個簡單形狀或複合形狀分組（ [菜單欄->編輯->分組/合併->分組選定的形狀] ）或取消分組（[ 菜單欄->編輯->分組/合併 ->取消組合所選形狀] ）。  (同一類型拆、組) \n 也可以合併簡單的形狀（ [菜單欄->編輯->分組/合併->合併選定的形狀] ，在這種情況下，所有組成元素的視覺屬性都相同。形狀也可以劃分（ [菜單欄 ->編輯->分組/合併->分割選定的形狀] ） (直接組成隨機形狀) ，具體取決於其配置：分割算法將提取形狀的每個不同元素，如果兩個元素不共享任何公共邊，則它們是不同的。 另請參閱模型教程，該教程說明瞭如何為仿真模型正確導入和準備形狀。 \n Pure shapes are mainly functional shapes. They are most of the time only used by the physics engine that performs on them much better and faster than on non-pure shapes (e.g. random or convex meshes). For that reason, pure shapes are often hidden in an invisible layer (e.g. layer 9). Refer to the \xa0 layer selection dialog \xa0 and the section on \xa0 how to design dynamic simulations \xa0 for more information. \n 純形狀主要是功能形狀。 大多數情況下，它們僅由物理引擎使用，它們對它們的性能要比對非純形狀（例如，隨機或凸形網格）好得多且更快。  因此，純形狀通常會隱藏在不可見的圖層（例如圖層9）中。 有關更多信息，請參考層選擇對話框和有關如何設計動態仿真的部分。 \n \n Pure simple shapes can also be grouped, the resulting compound shape will however only be pure if all of its composing elements are also pure. Merging pure simple shapes will result in a non-pure simple shape. \n 也可以對純簡單形狀進行分組，但是只有在其所有組成元素也都是純淨的情況下，生成的複合形狀才是純淨的。  合併純簡單形狀將導致非純簡單形狀。 \n Shapes are\xa0 collidable , \xa0 measurable , \xa0 detectable \xa0 and \xa0 renderable \xa0 objects. This means that shapes: \n 形狀是可碰撞，可測量，可檢測和可渲染的對象。  這意味著形狀： \n \n \n can be used in \xa0 collision detections \xa0 against other collidable objects. \n can be used in \xa0 minimum distance calculations \xa0 with other measurable objects. \n can be detected by \xa0 proximity sensors . \n can be detected by \xa0 vision sensors . \n \n \n 可用於對其他可碰撞物體的碰撞檢測。 \n 可與其他可測量對像一起用於最小距離計算。 \n 可以被接近傳感器檢測到。 \n 可以被視覺傳感器檢測到。 \n \n The collidable, measurable, detectable and renderable properties of a shape can be altered in the\xa0 object common properties . Additionally, those properties can be overridden if the shape is part of a \xa0 model \xa0 which overrides them. Refer to the \xa0 model dialog \xa0 for more information. \n 形狀的可碰撞，可測量，可檢測和可渲染的屬性可以在對象的公共屬性中進行更改。 此外， 如果形狀是覆蓋它們的模型的一部分，則可以覆蓋這些屬性。   有關更多信息，請參考模型對話框。 \n Shape properties(形狀屬性) \n The shape properties are part of the\xa0 scene object properties \xa0 dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the \xa0 scene hierarchy , or with a click on its \xa0 toolbar \xa0 button: \n 形狀屬性是場景對象屬性對話框的一部分，該對話框位於 [菜單欄->工具->場景對象屬性] 。 您也可以 通過雙擊場景層次結構中的對像圖標或單擊其工具欄按鈕 來打開對話框： \n \n The dialog displays the settings and parameters of the last selected shape. If more than one shape is selected, then some parameters can be copied from the last selected shape to the other selected shapes ( Apply to selection -buttons): \n 該對話框顯示最後選擇的形狀的設置和參數。 如果選擇了多個形狀，則可以將某些參數從最後選擇的形狀複製到其他選擇的形狀（適用於選擇按鈕）： \n \n \n \n Adjust color : allows editing the colors of the shape. \n \n 調整顏色： 允許編輯形狀的顏色。 \n \n Shading angle : the shading angle is the angle from which individual faces are distinguished. This only affects the visual appearance of a shape. A small angle makes a shape appear sharp, with many edges, a large angle makes a shape appear smooth and with less edges. \n \n 陰影角： 陰影角是區分各個面的角度。這僅影響形狀的視覺外觀。小角度使形狀看起來很銳利 ，有很多邊緣，大角度使形狀看起來很光滑且沒有邊緣。 \n \n Show edges : displays edges in black. Displayed edges will depend on the specified \xa0 angle . If \xa0 Hidden border \xa0 is checked, then edges that do not share more than one triangle will be hidden. \n \n 顯示邊緣： 以黑色顯示邊緣。顯示的邊緣將取決於指定的角度 。 如果選中了“隱藏邊框”，則不共享一個以上三角形的邊而將被隱藏。。 \n \n Backface culling : each triangle composing a shape has an inside and an outside face. When Backface culling is enabled, then inside faces won\'t be displayed. This is a useful parameter for closed shapes and for shapes that are transparent. \n \n 背面剔除： 組成形狀的每個三角形都有一個內表面和一個外表面。 啟用“背面剔除”後，將不會顯示內部面。這對於閉合形狀和透明形狀是有用的參數。 \n \n Invert faces : this flips all triangles. Inside faces become outside faces and vice-versa. Convex shapes will become non-convex, except for pure shapes. \n \n 反轉面： 反轉所有三角形。內表面變為外表面 ，反之亦然。除純形狀外，凸形狀將變為非凸形狀。 (先用反轉面反轉內外兩面這時候外表面就變成內表面，再用背面剔除就可以看到內部構造) \n \n Wireframe : if selected, then the shape will always appear as wireframe when seen through a \xa0 camera . \n \n 線框： 如果選中 ，則通過相機查看時， 形狀將始終顯示為線框。 \n \n Adjust texture : opens the \xa0 texture dialog \xa0 for the selected shape. When a shape is associated with a texture, it will be displayed in a textured way. \n \n 調整紋理： 打開所選形狀的紋理對話框。 當形狀與紋理關聯時，它將以紋理方式顯示。 \n \n Quick textures (selection) : applies a cubic mapped texture to all selected shapes. This is specially useful with seamless textures used as "dirt", in order to make objects look more realistic. \n \n 快速紋理（選擇）： 將立方貼圖紋理應用於所有選定的形狀。這對於用作“污垢”的無縫紋理特別有用，以使對像看起來更逼真。 \n \n Clear textures (selection) : removes the texture from all selected shapes. \n \n 清除紋理（選擇）： 從所有選定的形狀中刪除紋理。 \n \n View/modify geometry : opens the \xa0 shape geometry dialog \xa0 for the selected shape. It allows to adjust various parameters of the mesh. \n \n 查看/修改幾何： 打開所選形狀的 形狀幾何對話框。它允許調整網格的各種參數。 \n \n Show dynamic properties dialog : toggles the \xa0 shape dynamics properties \xa0 dialog. The shape dynamics dialog allows to adjust a shape\'s dynamics properties. \n \n 顯示動態屬性對話框： 切換形狀動力學屬性對話框。 形狀動力學對話框允許調整形狀的動力學屬性。 \n \n Some of above\'s parameters are only available for simple shapes. When a compound shape is selected, then you can edit its visual attributes by switching to the shape edit mode for compound shapes. You can of course also ungroup it in order to individually edit its components. \n 以上某些參數僅適用於簡單形狀。 選擇複合形狀後，您可以通過切換到復合形狀的形狀編輯模式來編輯其視覺屬性。  當然，您也可以取消分組，以便分別編輯其組件。 \n Shape dynamics properties(形狀動力屬性) \n The shape dynamics dialog is part of the\xa0 shape properties . The dialog displays the dynamics settings and parameters of the last selected \xa0 shape . If no object is selected, the dialog is inactive. If more than one shape is selected, then some parameters can be copied from the last selected shape to the other selected shapes ( Apply to selection -buttons): \n 形狀動力學對話框是形狀屬性的一部分。  該對話框顯示最後選擇的形狀的動力學設置和參數。  如果未選擇任何對象，則該對話框處於非活動狀態。 如果選擇了多個形狀，則可以將某些參數從最後選擇的形狀複製到其他選擇的形狀（適用於選擇按鈕）： \n \n \n \n Body is respondable : if enabled, then the shape will produce a collision reaction with other respondable shapes, however only if the respective respondable masks overlap (see the item below). See also the \xa0 designing dynamic simulation \xa0 section for more details. \n \n 主體是可響應的： 如果啟用，則該形狀將與其他可響應形狀產生碰撞反應，但是僅當相應的可響應 掩碼 重疊 (同時取消才不會產生碰撞) 時 （請參閱以下項目）。有關更多詳細信息，另請參見設計動態仿真部分。 \n \n Respondable mask : indicates when a collision response is generated (above respondable item needs however to be enabled). The mask is composed by two 8-bit values, local and global. If two colliding shapes share any of their parents (direct or indirect), then the local masks are used, otherwise the global masks are used. If two shapes\' \xa0 AND -combined masks (local or global) is different from zero, then a collision response will be generated. \n \n 響應式掩碼 \xa0 ：指示何時生成碰撞響應（但是需要啟用以上響應項）。 \xa0 該掩碼由局部和全局兩個8位值組成。 \xa0 如果兩個碰撞形狀共享其任何母體（直接 或間接），則使用局部掩碼，否則使用全局掩碼。 \xa0 如果兩個形狀的 AND 組合掩碼（局部或全局）不為零，則將生成碰撞響應。 \n \n Edit material : allows you to edit \xa0 material properties \xa0 for all dynamics engines, such as friction, restitution, etc. \n \n 編輯材料 \xa0 ： 允許您編輯所有動力學引擎 的材料屬性 \xa0 ，例如 摩擦 ，復原等。 \n \n Body is dynamic : when enabled, then the shape\'s position and orientation will be influenced in a \xa0 dynamics simulation . See the \xa0 designing dynamic simulation \xa0 section for more details. \n \n 身體是動態的 \xa0 ： 啟用後，形狀的位置和方向將在動力學模擬中受到影響。 \xa0 有關更多詳細信息，請參見設計動態仿真部分。 \n \n Start in sleep mode : a respondable shape that is dynamically simulated can start in sleep mode, in which case it doesn\'t react to constraints (e.g. gravity) until it first collides with another respondable shape. \n \n 從睡眠模式開始 \xa0 ：動態模擬的可響應形狀可以在睡眠模式下開始，在這種情況下，它在首先與另一個可響應形狀發生碰撞之前不會對約束（例如重力）做出反應。 \n \n Set to dynamic if gets parent : when enabled and the shape is attached to another object, then the shape will be automatically made dynamic. This is useful for model bases that should be static when on their own, but dynamic when combined with another model/object (e.g. a robotic manipulator that operates on its own usually has its base static, but when attached to a vehicle, then the base should become dynamic). \n \n 如果成為母體，則設置為動態\xa0： 啟用該選項並將形狀附加到另一個對象時，該形狀將自動變為動態。 \xa0 這對於單獨使用模型基礎時應該是靜態的，但是當與另一個模型/對象結合時是動態的（例如，自己操作的機器人操縱器通常具有其基礎是靜態的，但是當附加到車輛上時，則該基礎是動態的） 應該變得充滿活力）。 \n \n Compute mass & inertia properties for the selected shapes : by clicking this button, you can automatically compute the mass and inertia properties of the selected convex shapes, based on a material uniform density. \n \n 計算選定形狀的質量和慣性屬性 \xa0 ： 單擊此按鈕，可以基於材料均勻密度自動計算選定凸形狀的質量和慣性屬性。 \n \n Mass : the mass of the shape. Selected shapes can have their masses easily increased or decreased by a factor 2 with the \xa0 M=M*2 (for selection) \xa0 and the \xa0 M=M/2 (for selection) \xa0 buttons. This is convenient to quickly find stable simulation parameters by trial-and-error. \n \n 質量 \xa0 ：形狀的質量。 \xa0 使用 M = M * 2（用於選擇） 和 M = M / 2（用於選擇） 按鈕，可以輕鬆地將選定的形狀的質量增加或減少2倍。 \xa0 通過試驗和錯誤快速方便地找到穩定的仿真參數。 \n \n Principal moments of inertia / mass : the mass-less (i.e. divided by the mass of the shape) principal moments of inertia. Selected shapes can have their mass-less inertia values easily increased or decreased by a factor 2 with the \xa0 I=I*2 (for selection) \xa0 and the \xa0 I=I/2 (for selection) \xa0 buttons. This is convenient to quickly find stable simulation parameters by trial-and-error. \n \n 主慣性矩/質量 \xa0 ：無質量（即除以形狀的質量）主慣性矩。 \xa0 使用 I = I * 2（用於選擇） 和 I = I / 2（用於選擇） 按鈕，可以輕鬆地將選定的形狀的無質量慣性值增加或減小2倍。 \xa0 通過試驗和錯誤快速方便地找到穩定的仿真參數。 \n \n Pos./orient. of inertia frame & COM relative to shape frame : the configuration of the inertia frame and center of mass expressed relative to the \xa0 shape\'s reference frame . \n \n 位置/東方 \xa0 慣性系和COM相對於形狀系的坐標： 慣性系的配置和質心相對於形狀的參考系的表示。 \n \n Set inertia matrix & COM relative to absolute frame:  opens the inertia matrix dialog, allowing to specify inertia properties relative to the absolute reference  frame: \n \n 設置相對於絕對坐標系的慣性矩陣和COM \xa0： 打開慣性矩陣對話框，允許指定相對於絕對參考系的慣性屬性： \n \n \n \n Inertia matrix divided by the mass : the inertia matrix or tensor. Values are mass-less (i.e. divided by the mass of the shape). The matrix must be expressed relative to the center of mass of the shape (i.e the matrix is symmetric). \n \n 慣性矩陣除以質量 \xa0 ： 慣性矩陣或張量。 \xa0 值無質量（即除以形狀質量）。 \xa0 矩陣必須相對於形狀的質心表示（即矩陣是對稱的）。 \n \n Position of the center of mass : the position of the center of mass. \n \n 重心 位置： 重心位置 \n \n Apply to selected shapes : when checked, then all selected shapes will have the same inertia properties relative to the absolute reference frame (i.e. all center of masses and inertia matrices will be coincident). \n \n 應用於選定的形狀 \xa0 ：選中後，所有選定的形狀相對於絕對參考係將具有相同的慣性屬性（即，所有質心和慣性矩陣都將重合）。 \n \n \n \n Joints(軸節) \n \n A joint is an \xa0 object \xa0 that has at least one intrinsic Degree of Freedom (DoF). Joints are used to build mechanisms and to move objects as can be seen in following figures: \n 軸節是具有 至少一個固有自由度 （DoF）的對象。 \xa0 關節用於 建立機制和移動對象 ，如下圖所示： \n \n Joints are added to the \xa0 scene \xa0 with [menu bar --> Add --> Joint]. Refer to the \xa0 joint section in the model creation tutorial . Some joint data can be recorded by graph objects. Refer to \xa0 graphs \xa0 and \xa0 graph data streams \xa0 for more information about how to record joint data. \n 使用 [菜單欄->添加->關節] 將關節添加到場景。 \xa0 請參閱模型創建教程中的聯合部分。 \xa0 某些聯合數據可以由圖形對象記錄。 \xa0 有關如何記錄聯合數據的更多信息，請參考圖形和圖形數據流。 \n \n Joint types and operation(軸節類型和操作) \n Compared to another\xa0 object , a \xa0 joint \xa0 has two reference frames (visible only if the joint is selected). The first one is the regular reference frame that is fixed and that other objects also have. The second reference frame is not fixed, and will move relative to the first reference frame depending on the joint position (or joint value) that defines its configuration. \n 與另一個對象相比，\xa0 軸節具有兩個參考系 （僅在選擇軸節時可見）。 \xa0 第 一個是固定的常規參照系，其他對像也具有。 \xa0 第二參考框架不是固定的，並且將根據定義其配置的關節位置（或關節值）相對於第一參考框架移動。 \n Joint types \n 軸節類型 \n 4 types of joints are supported: \n 支持4種類型的關節： \n \n \n Revolute joints : revolute joints have one DoF and are used to describe rotational movements (with 1 DoF) between objects. Their configuration is defined by one value that represents the amount of rotation about their first reference frame\'s z-axis. They can be used as passive joints, or as active joints (motors). \n \n 旋轉軸節 \xa0 ： 旋轉軸節具有一個自由度 ，用於描述對象之間的旋轉運動（具有1個自由度）。 \xa0 它們的配置由一個值定義， 該值代表圍繞其第一參考框架的z軸旋轉的量。 \xa0 它們可以用作被動軸節，也可以用作 主動軸節（電動機） 。 \n \n Prismatic joints : prismatic joints have one DoF and are used to describe translational movements between objects. Their configuration is defined by one value that represents the amount of translation along their first reference frame\'s z-axis. They can be used as passive joints, or as active joints (motors). \n \n 棱形軸節 \xa0 ：棱柱形軸節具有一個自由度，用於描述對象之間的平移運動。 \xa0 它們的配置由一個值定義， 該值表示沿其第一個參考框架的z軸的平移量。 \xa0 它們可以用作被動軸節，也可以用作主動軸節（電動機）。 \n \n Screws : screws, which can be seen as a combination of revolute joints and prismatic joints (with linked values), have one DoF and are used to describe a movement similar to a screw. A pitch parameter defines the amount of translation for a given amount of rotation. A screw configuration is defined by one value that represents the amount of rotation about its first reference frame\'s z-axis. Screws can be used as passive joints, or as active joints (motors). \n \n 螺旋 \xa0 ：螺旋， 可以看作是旋轉軸節和棱柱軸節（具有關聯值）的組合 ，具有一個自由度，用於描述類似於螺旋的運動。 \xa0 螺距參數定義給定旋轉量的平移量 。 \xa0 螺釘配置由一個值定義， 該值表示圍繞其第一個參考框架的z軸的旋轉量。 \xa0 螺釘可以用作被動接頭，也可以用作主動接頭（電動機）。 \n \n Spherical joints : spherical joints have three DoF and are used to describe rotational movements (with 3 DoF) between objects. Their configuration is defined by three values that represent the amount of rotation around their first reference frame\'s x-, y- and z-axis. The three values that define a spherical joint\'s configuration are specified as \xa0 Euler angles . In some situations, a spherical joint can be thought of as 3 concurrent and orthogonal to each other joints, that are parented in a hierarchy-chain. The analogy is however only valid while all revolute joints keep an orientation distinct from any of the two others: indeed, should two joints come close to coincide, a singular situation might appear and the mechanism might lose one DoF. This does never happen with spherical joints that are internally handled to avoid this kind of situation. Spherical joints are always passive joints, and cannot act as motors. \n \n 球形關節 \xa0 ： 球形關節具有三個自由度，用於描述對象之間的旋轉運動（具有3個自由度） 。 \xa0 它們的配置由三個值定義，這些值代表圍繞其第一個參考系的x軸，y軸和z軸的旋轉量。 \xa0 定義球形接頭配置的三個值指定為Euler Angles \xa0 。 \xa0 在某些情況下，球形關節可以看作是3個並發且彼此垂直的關節，它們是層次結構鏈中的母體。 \xa0 但是，該類比僅在所有旋轉關節保持不同於其他兩個關節的方向時才有效：實際上，如果兩個關節接近並重，則可能出現單一情況，並且該機制可能會失去一個自由度。 \xa0 對於內部避免這種情況的球形接頭，這種情況永遠不會發生。 \xa0 球形接頭始終是被動接頭 ，不能充當馬達。 \n \n A joint is used to allow for a relative movement between its parent and its children. When a parent-child relationship is built between a joint and an object, the object is attached to the joint\'s second reference frame, thus, a change of the joint\'s configuration (intrinsic position) will directly be reflected onto its children. New joints can be added to a \xa0 scene \xa0 with [Menu bar --> Add --> Joints]. \n 關節用於允許其母體和子對象之間的相對運動。 \xa0 當在關節和對象之間建立父子關係時，該對象將附著到關節的第二參考框架，因此，關節構型的改變（固有位置）將直接反映到其子對像上。 \xa0 可以使用[菜單欄->添加->關節]將新關節添加到場景中。 \n \xa0 \n  Joint modes \n  軸節模式 \n A joint can be in one of following modes: \n 軸節可以採用以下方式之一： \n \n \n Passive mode : in this mode the joint is not directly controlled and will act as a fixed link. The user can however change the joint\'s position with appropriate \xa0 API \xa0 function calls (e.g. \xa0 sim.setJointPositon \xa0 or \xa0 sim.setSphericalJointMatrix ). \n \n 被動模式 \xa0 ： 在此模式下，軸節不受直接控制，將充當固定鏈接。 \xa0 但是，用戶可以使用適當的API函數調用（例如sim.setJointPositon或sim.setSphericalJointMatrix \xa0 ）來更改關節的位置。 \n \n Inverse kinematics mode : in this mode, the joint acts as a passive joint, but is used (adjusted) during \xa0 inverse kinematics calculations . \n \n 逆運動學模式 \xa0 ： 在此模式下，軸節充當被動關節 ，但在逆運動學計算 期間使用（調整）。 \n \n Dependent mode : in this mode, the joint position is directly linked (dependent) to another joint position through a linear equation. \n \n 從屬模式 \xa0 ：在 此模式下，關節位置通過線性方程式直接鏈接（依賴）到另一個關節位置。 \n \n Motion mode : \xa0 this mode is deprecated \xa0 and should not be used anymore. A similar and more flexible behaviour can be obtained with the \xa0 passive mode \xa0 and a \xa0 child script \xa0 appropriately updating the joint. \n \n 動作模式 \xa0 ：不建議使用 此模式 。 \xa0 使用 被動模式 和適當更新關節的子腳本可以獲得類似和更靈活的行為。 \n \n Torque or force mode : in this mode, the joint is simulated by the \xa0 dynamics module , if and only if it is dynamically enabled (refer to the section on \xa0 designing dynamic simulations \xa0 for more information). When dynamically enabled, a joint can be free or controlled in Force/torque, in velocity or in position. Screws cannot be operated in torque or force mode (however it is possible to obtain a similar behaviour by linking a revolute and prismatic joint programmatically), and spherical joints can only be free in torque or force mode. \n \n 扭矩或力模式 \xa0 ： 在此模式下，當且僅當動態啟用關節時，才通過動力學模塊對關節進行模擬 （有關更多信息，請參考設計動態仿真的部分）。 \xa0 動態啟用後，關節可以自由受力/扭矩，速度或位置或受其控制。 \xa0 螺釘不能在扭矩或力模式下操作（但是，可以通過編程方式連接旋轉接頭和棱柱形接頭來獲得類似的行為），球形接頭只能在扭矩或力模式下自由操作。 \n \n ----------------------------------- \n \n When the joint motor is disabled, the joint is free and only constrained by its limits. \n \n 禁用軸節發動機時，軸節是自由的，並且僅受其限制。 \n \n When the joint motor is enabled and the control loop is disabled, then the joint will try to reach the desired target velocity given the maximum torque/force it is capable to deliver. When that maximum torque/force is very high, the target velocity is instantaneously reached and the joint operates in velocity control, otherwise it operates at the specified torque/force until the desired target velocity is reached (torque/force control). \n \n 啟用關節電動機並禁用控制迴路後，如果關節能夠傳遞最大扭矩/力，則關節將嘗試達到所需的目標速度。 \xa0 當 最大扭矩/力非常高時，即刻達到目標速度，並且關節以速度控制方式運行，否則關節將以指定的扭矩/力進行操作，直到達到所需的目標速度（扭矩/力控制）。 \n \n When the joint motor is enabled and the control loop is enabled, then the user has 3 control modes available: \n \n 啟用軸節發動機並啟用控制迴路後 ，用戶可以使用3種控制模式： \n \n \n Custom control : a \xa0 joint callback function \xa0 will be in charge of controlling the dynamic behaviour of the joint, allowing you to control the joint with any imaginable algorithm. \n \n 自定義控件 \xa0： \xa0 關節回調函數 將負責控制軸節的動態行為 ，使您 可以使用任何可想像的算法來控制關節。 \n \n Position control (PID) : the joint will be controlled in position via a PID controller that will adjust the joint velocity in following way (the \xa0 Δt \xa0 divider is to keep the controller independent of the selected controller time step): \n \n \n 位置控制（PID）\xa0： 將 通過PID控制器控制關節的位置 ，該PID控制器將以以下方式 調整軸節速度 （ \xa0 Δt 分頻器將使控制器獨立於所選控制器時間步長）： \n \n \n \n Spring-damper mode : the joint will act like a spring-damper system via a force/torque modulation: \n \n 彈簧-阻尼器模式 \xa0： 通過力/扭矩調製 ，軸節將像彈簧-阻尼器系統一樣工作： \n \n When the joint is in passive mode, inverse kinematics mode or dependent mode, it can optionally also be operated in a hybrid fashion: \n hybrid operation allows the joint to operate in a regular way, but additionally, just before \xa0 dynamics calculations , the current joint position will be copied to the target joint position, and then, during dynamics calculations, the joint will be handled as a motor in position control (if and only if it is dynamically enabled (refer to the section on \xa0 designing dynamic simulations \xa0 for more information)). This feature allows for instance to control the leg of a humanoid robot by simply specifying the desired foot position (as an inverse kinematics task); the corresponding calculated joint positions will then be applied as position control values for the leg dynamic motion. \n 當關節處於被動模式，逆運動學模式或從屬模式時，還可以選擇以混合方式進行操作： \n 混合操作允許關節以常規方式進行操作，但此外，在進行動力學計算之前，當前關節位置將被複製到目標關節位置，然後在動力學計算期間，將關節作為位置控制中的電動機處理（如果且僅當它被動態啟用時（有關更多信息，請參閱設計動態模擬的部分）） 。 \xa0 例如，該功能允許通過簡單地指定所需的腳部位置（作為反向運動學任務）來控制人形機器人的腿部； \xa0 然後，將計算出的相應關節位置用作腿部動態運動的位置控制值。 \n \n  Joint  controllers \n  軸節控制器 \n There are many different ways a joint can be controlled. In following section, we differentiate betwen a\xa0 loose \xa0 controller and a \xa0 precise \xa0 controller: a \xa0 loose \xa0 joint controller will not be able to provide new control values in each possible regulation step (e.g. some regulation steps might/will be skipped, but control is still possible). A \xa0 precise \xa0 joint controller on the other hand, will be able to provide control values in each possible regulation step. \n 關節有許多不同的控制方法。 \xa0 在以下部分中，我們將 鬆動 控制器與 精確 控制器區分開： \xa0 鬆動關節控制器將無法在每個可能的調節步驟中提供新的控制值（例如，可能/將跳過某些調節步驟，但仍然可以進行控制）  。 \xa0 另一方面， \xa0精確的關節控制器將能夠在每個可能的調節步驟中提供控制值。 \n First, the approach to take for controlling a joint will depend on the joint mode: \n 首先，控制關節的方法將取決於關節模式： \n \n \n The joint is not in force/torque mode . \n The joint operates in force/torque mode . \n \n \n \n 關節未處於力/扭矩模式 。 \n 關節以力/扭矩模式運行 。 \n \n \n \n If the joint is not in force/torque mode : if the joint is not in force/torque mode, then you can directly (and instantaneously) set its position via the \xa0 sim.setJointPosition \xa0 API function (or similar, e.g. \xa0 simxSetJointPosition \xa0 for the B0-based remote API, or \xa0 simxSetJointPosition \xa0 for the legacy remote API). You can do this from a \xa0 child script , from a \xa0 plugin , from a \xa0 ROS \xa0 node, from a \xa0 BlueZero \xa0 node, or from a \xa0 remote API \xa0 client. If you do this from a child script, then it should be done inside of the \xa0 actuation section \xa0 of the \xa0 non-threaded child script , or from a \xa0 threaded child script \xa0 that executes before the \xa0 sensing phase \xa0 of the \xa0 main script \xa0 (default). In the latter case however, make sure to have your threaded child script synchronized with the simulation loop for \xa0 precise \xa0 control. \n 如果關節未處於力/轉矩模式 \xa0：如果關節未處於力/轉矩模式，則 可以通過sim.setJointPosition API函數 （或類似方法，例如B0-的simxSetJointPosition ） 直接（並立即）設置其位置。 基於基礎的遠程API，或針對舊版遠程API的simxSetJointPosition ）。  您可以通過子腳本 ， 插件 ， ROS節點， BlueZero節點或遠程API客戶端來執行此操作。  如果 從子腳本執行此操作，則應在非線程子腳本的驅動部分內部執行，或者從在主腳本的感知階段之前執行的線程子腳本 （默認）執行。  但是，在後一種情況下，請確保將線程化的子腳本與模擬循環同步以進行精確控制。 \n In following\xa0 threaded child script \xa0 example, the joint is controlled \xa0 loosely \xa0 in position, and there is no synchronization with the simulation loop: \n 在下面的線程子腳本示例中，關節的位置鬆散地受到控制，並且與仿真循環沒有同步： \n \n In following\xa0 threaded child script \xa0 example, the joint is controlled \xa0 precisely \xa0 in position in each simulation step, i.e. the thread is synchronized with the simulation loop: \n 在下面的線程子腳本示例中，在每個模擬步驟中精確控制關節的位置，即，線程與模擬循環同步：在下面的線程子腳本示例中，在每個模擬步驟中精確控制關節的位置，即，線程與模擬循環同步： \n', 'tags': '', 'url': 'Entities(實體).html'}, {'title': 'Simulation(模擬)', 'text': "A simulation in CoppeliaSim can be started, paused and stopped with [Menu bar --> Simulation --> Start/Pause/Stop simulation] or through the related toolbar buttons: \n 可以使用 [菜單欄->模擬->開始/暫停/停止模擬] 或通過相關的工具欄按鈕來啟動，暫停和停止CoppeliaSim中的模擬： \n \n Internally(在內部) ,\xa0the\xa0 simulator(模擬器) \xa0will use\xa0 additional(額外)\xa0intermediate(中間)\xa0 states in order to\xa0 correctly(正確地)\xa0 inform \xa0 scripts (告知腳本) \xa0or programs about what will happen next. Following\xa0state  diagram(狀態圖)\xa0illustrates(說明) \xa0the simulator's \xa0internal(內部) \xa0states: \n 在內部， 模擬器將使用其他中間狀態 ，以正確告知腳本或程序接下來將發生的情況。 \xa0 以下 狀態圖說明了模擬器的內部狀態 ： \n \n . \n Scripts and programs should \xa0 alwaysreact(總是反應) \xa0 according to the current system call function and possibly the simulation state in order to \xa0 behave  correctly(正確運行) . It is good practice to \xa0 divide each(劃分每個) \xa0 control code into \xa0 at\xa0least(至少)\xa0 4 system call functions (e.g. for \xa0 non-threaded(非線性) \xa0 child scripts): \n 腳本和程序應始終根據當前系統調用功能以及可能的模擬狀態進行反應 ，以便正確運行。 優良作法是 將每個控制代碼 至少分為4個系統調用函數 （例如，用於非線程子腳本）： \n \n In itialization(初始化) \xa0function: \xa0 sysCall_init: the function is called only when the script is \xa0 initialized(初始化) . \n \n 初始化函數： sysCall_init：僅在腳本初始化時才調用該函數。 \n \n Actuation(激活 ) \xa0 function: \xa0 sysCall_actuation: the function is called when actuation should happen. \n \n 激活函數 ：sysCall_actuation：應在發生激活時調用該函數。 \n \n Sensing(感測)\xa0 function: \xa0 sysCall_sensing: this function is called when sensing should happen. \n \n 感測功能： sysCall_sensing：應在感測發生時調用此函數。 \n \n Clean-up(清理) \xa0 function: \xa0 sysCall_cleanup: the function is called just before the script is \xa0 de-initialized(未初始化) \xa0 (e.g. at simulation end, or when the script is \xa0 destroyed(銷毀) ). \n \n 清理函數： sysCall_cleanup：該函數在腳本未初始化之前被調用（例如在模擬結束時或腳本被銷毀時)。 \n", 'tags': '', 'url': 'Simulation(模擬).html'}, {'title': 'Assignment 2', 'text': 'MechanicalDesignProcess(機械設計過程) \n . \n PG4 Materials and Processes(材料與工藝) \n 4.1 Cost Versus Time Versus Specification(成本與時間與規格) \n we’ll return to cost considerations of the design. With that reestablishment of this design “touchstone,” we’ll do with more “building blocks” that will be available to the designer to determine the best materials and processes for their enclosure parts. \n 我們將回到設計的成本考慮因素。 通過重新設計“試金石”，我們將 設計更多的“構建基塊”以供設計師使用 確定其外殼零件的最佳材料和工藝。 \n There are cases where prototypes required for the final design need to be developed. These “prototypes” are certainly less cost-sensitive, as it is time that is usually the critical factor here. However, even though the prototype itself may not have a cost-sensitivity, the overall project cost is impacted in the sense that cost is sacrificed for speed just in the prototype portion of the project \n 在某些情況下，需要開發最終設計所需的原型。這些“原型”當然對成本不太敏感，因為時間通常是這裡的關鍵因素。然而， 即使原型本身可能不具有成本敏感性，但整個項目的成本 在某種意義上受到影響，因為僅在原型的一部分中就犧牲了速度成本 該項目 \n Time plays into this “cost picture” very much. The “time-to-market” can be a huge driver in product development. That is, if a certain product isn’t released in some specific time frame (such as the spring planting season or the electronic show before the holidays), that can mean a huge difference to the total sales of the product. So, coupled with cost is the aspect of time. \n 時間在這個“成本圖”中扮演了非常重要的角色。 “上市時間”可能是產品開發的巨大推動力。 也就是說，如果某個產品沒有在某個特定的時間範圍內發布（例如春季播種季節或節假日前的電子展覽），則可能對產品的總銷售額產生巨大的影響。 因此，成本是時間的一部分。 \n Emphasis on time in material/process/manufacturability choice for the early stages of the development process  A “high-production” and cost-reduced product release can come occur in the later stages of the development process \n 1.儘早選擇材料/工藝/可製造性 開發過程的各個階段 \n 2.在產品中可能會出現“高產量”和降低成本的產品發布。 開發過程的後期 \n >>it could have been determined that the overall cost is minimized by a “two-stage” \n 可以確定通過上述“兩階段”將總成本降至最低 \n . \n Cost can also be broken down into several time frames, such as: \n 成本也可以細分為多個時間範圍，例如： \n \n Development cost (until first shipment to customer) \n Ongoing production cost of the product: materials/assembly/overhead \n Service and warranty costs after production \n End-of-life costs such as recycling \n \n 1. 開發成本 （直到首次交付給客戶） \n 2. 產品的持續生產成本：材料/組裝/間接費用 \n 3. 生產後的服務和保修成 本 \n 4. 報廢費用，例如回收利用 \n . \n Basic factors affecting costs: \n 影響成本的基本因素： \n • Materials of the individual parts. \n • Process needed to produce the above parts. \n • Assembly procedure needed to assemble above parts. \n • Testing procedure needed to test above parts and assemblies. \n • Quality control procedures in place to assure parts and assemblies are produced and assembled to specifications. \n • Service (expected or unexpected) requirements are met. \n • 各個零件的材料。 \n • 生產上述零件所需的過程。 \n • 組裝上述零件所需的組裝程序。 \n • 測試上述零件和組件所需的測試程序。 \n • 制定質量控製程序以確保零件和組件的生產 並按照規格組裝。 \n • 滿足服務（預期或意外）要求。 \n 4.3 Materials and Process Choice(材料和工藝的選擇) \n Once a designer has designed a part, the designer must determine the “best” Cost way for that part to be produced. The general items to be determined for each part are: \n 設計人員設計完零件後，必須確定要生產該零件的“最佳”成本方式。每個部分要確定的一般項目是： \n • Material of the part. \n • Finish required for the part (see next section). \n • Dimensional accuracy needed for the part. \n • Process by which that part will be produced (perhaps one process for early needs,prototyping, and preproduction of parts and a different process for mature production of the parts). \n • Quantity needed of the part (say, per quarter, per month, per year). \n • Second operations needed for the part (beyond finishing). \n • Cost requirements for the part. \n • Can this part be combined with another part in the design? Essentially, whatneeds to be determined is whether a single (combined) part can fulfill the functionality of the separate parts . \n • Can the part be made symmetrical (for assembly ease)? Should the part that is almost symmetrical be made a more obvious \n • 零件的材料。 \n • 零件需要的表面處理 （請參閱下一節）。 \n • 零件所需的尺寸精度。 \n • 生產零件的過程 （也許是用於早期需求，原型設計和零件預生產的過程，以及用於零件成熟生產的不同過程）。 \n • 零件所需的數量 （例如，每季度，每月，每年）。 \n • 零件需要的第二次操作 （超出精加工）。 \n • 零件的成本要求。 \n •該部分可以與設計中的另一部分組合嗎？本質上，需要確定的是單個（組合）部分是否可以滿足單獨部分的功能。 \n •零件可以做成對稱的（為了便於組裝）嗎？應該把幾乎對稱的部分做成一個更明顯的非對稱部分嗎？這兩個問題涉及該零件的組裝以及以不正確的方式組裝的可能性。可以僅為使零件對稱而在零件上添加孔或缺口（多餘的）。 \n . \n Considerations for determining material selection for a part: \n 確定零件的材料選擇的注意事項： \n The designer should choose a material that will satisfy (meet or exceed): \n 設計者應選擇滿足（超過）要求的材料： \n \n Strength requirements \n Weight requirements \n Reliability requirements \n Regulatory requirements \n Safety requirements \n Thermal requirements \n Shielding requirements (EMI/RFI) \n Compatibility requirements for metals (galvanic corrosion) \n Elastic requirements (durometer) \n Conductive (or insulating) requirements \n Opaqueness requirements \n Wear requirements \n Aesthetical requirements (touch, visual) \n Acoustical requirements \n Ultraviolet (UV) transmission and resistance requirements \n \n 1. 強度要求 \n 2. 重量要求 \n 3. 可靠性要求 \n 4. 法規要求 \n 5. 安全要求 \n 6. 散熱要求 \n 7. 屏蔽要求 （EMI / RFI） \n 8. 金屬的兼容性要求（電腐蝕） \n 9. 彈性要求 （硬度計） \n 10. 導電（或絕緣）要求 \n 11. 不透明要求 \n 12. 磨損要求 \n 13. 審美要求（觸覺，視覺） \n 14. 聲學要求 \n 4.7\xa0Casting Metals(鑄造金屬) \n There are actually quite a few processes for forming plastics, the same can be said for the casting process. There are many casting techniques. The casting techniques generally vary by: \n 實際上有很多塑料成型工藝，鑄造工藝也可以說相同。 有很多鑄造技術。 鑄造技術通常因以下因素而異： \n • Metal cast • Size range of part normally cast • Tolerances expected to be held by process • Cost of tooling • Part price • Surface finish expectation • Minimum draft recommended • Normal minimum section thickness • Ordering quantity • Normal lead time • Die casting • Permanent mold • Investment (lost wax) • Plaster mold • Ceramic mold • Graphite mold • Resin shell mold • Sand casting \n \n • 金屬鑄件 • 正常鑄造零件的尺寸範圍 • 公差應按工序確定 • 工具成本 • 單價 • 表面光潔度期望 • 建議的最低吃水深度 • 正常最小截面厚度 • 訂購數量 • 正常的交貨時間 • 壓鑄 • 永久模具 • 投資（失蠟 ） • 石膏模具 • 陶瓷模具 • 石墨模具 • 樹脂殼模具 • 砂模鑄造 \n 4.8 Dimensioning/Tolerancing\xa0 ( 尺寸/公差) \n 4.8.1 Choice of “Nominal Dimension”\xa0 (“公稱尺寸”的選擇) \n If this is not done correctly, the parts are in a rather constant state of “not fitting” and “out of tolerance,” and assembly line stop-page will occur. assembly and serviceability, as properly dimensioned and toleranced parts will lead to very smooth manufacturing assembly of those parts.Some comments about the English system of units vs. metric system of units are also appropriate (see separate discussion). I even want to start this discussion with how I actually started design “parts” (which were actually tooling fixtures and jigs to perform machining or welding of parts). \n 如果操作不正確，則零件處於“不適合”和“超出公差”的相當恆定的狀態，並且將發生裝配線停工。 裝配和可維修性，因為適當尺寸和公差的零件將導致這些零件的製造裝配非常順暢。關於英制單位制和公制單位制的一些評論也是適當的（請參閱單獨的討論）。 我什至要開始討論如何實際開始設計“零件”（實際上是工裝夾具和夾具）。 進行零件的機加工或焊接）。 \n 4.8.2 United States Engineering Units Versus International System of Units\xa0 \xa0 \xa0 (美國工程單位與國際單位制) \n My comments about dimensioning/tolerances are useful in either system of units (inches or millimeters). In the United States, we may start a design thinking that 3.000 inches is nominal or “the place to start.” In Europe, the “same” place to start might be 75 millimeters (which is equal to 2.953 inches). If a design starts in the United States at 3.000 inches, those drawings are exactly converted to 3 × 25.4 = 76.2 millimeters if the product is to be manufactured in Europe. I’m trying to make a distinction between “conversion factor” (inches to millimeters) and “designer origin mindset.” So, if I was a designer in the United States (with a US education), who was designing a part for a European firm, I would probably create a design that had its start with an “even” millimeter nominal dimen-sion, so I would start with 75 millimeters as that size (instead of choosing 3.000 inch). \n 我對尺寸/公差的評論在單位制（英寸或毫米）中都非常有用。 在美國，我們可能開始設計時以3.000英寸為標稱尺寸或“起點”。 在歐洲，“相同”的起點可能是75毫米（等於2.953英寸）。 如果設計在美國以3000英寸開始，那麼如果要在歐洲製造產品，則將這些圖紙精確地轉換為3×25.4 = 76.2毫米。 我試圖在“轉換係數”（英寸到毫米）和“設計師出身的思維方式”之間進行區分。 因此，如果我是一位美國設計師（接受過美國教育），當時正在為一家歐洲公司設計零件，那麼我可能會創建一個以“甚至”毫米標稱尺寸開始的設計，因此 我將從75毫米開始（而不是選擇3.000英寸）。 \n 4.8.4 Overall Size and the Design (總體尺寸和設計 為了繼續進行尺寸標註) \n To continue the general topic of dimensioning and how it relates to design, Some constraints will usually be the start of a design. Here are some examples: The general assumptions for the examples are: \n 為了繼續進行尺寸標註及其與設計的一般性主題，通常會遇到一些約束。 \n 這裡有些例子： 這些示例的一般假設為： \n The general assumptions for the examples are: Minimum size and weight, Cost (Chpt4), are required in the design. Minimum clearance between one object and another is 0.010 inch. This obviouslyvaries in a real design and depends on the objects and environment that the enclo-sure will be used. \n 設計中需要最小尺寸和重量，成本（Chpt4）。 一個物體與另一個物體之間的最小間隙為0.010英寸。 顯然，這在實際設計中會有所不同，並且取決於要使用外殼的對象和環境。 \n 4.8.5 Theory of Tolerancing: The Need (4.8.5寬容理論：需要) \n Tolerancing on part dimensions is needed as parts cannot be produced perfectly. Manufacturing techniques do not produce perfect parts. This is probably obvious. The actual amount of tolerance is based on a few (probably competing) factors: \n 由於零件無法完美生產，因此需要零件尺寸公差。 製造技術不能生產出完美的零件。這可能是顯而易見的。 實際的公差量基於幾個（可能是相互競爭的）因素： \n \n 成本 （較大的公差製造成本較低）。 \n 相似的零件 （同一零件）需要互換-所有零件都是 公差必須起作用。 \n 與其他零件配合的零件必須在所有零件都達到其公差極限的情況下執行此操作。因此，指定公差的“ 默認步驟 ”是： \n \n A.Choose the tolerance for the reasonable or most common manufacturing process. \n 選擇合理或最常見的製造過程的公差。 \n B. If the above is acceptable to the design, look to increase the tolerance even more,checking back to acceptability in the overall design. Increasing the tolerance will allow more parts to pass inspection, which should (could) result in overall cost reduction. \n 如果上述設計可接受，請尋求更大的公差，並重新檢查總體設計的可接受性。增加容忍度允許更多零件通過檢查，這將（可能）導致總體成本降低。 \n C. Tighten the tolerance even though the most common manufacturing process will not produce that tolerance if the design dictates that tighter tolerance. Check with the part manufacturer if that tighter tolerance will be achievable (reason-ably) or at what cost.Each dimension (location, hole size, angle, etc.) must have a tolerance, either explicitly stated on the drawing or as being a part of an overall notation on thedrawing. \n 收緊公差，即使最常見的製造工藝在設計要求更嚴格的公差的情況下也不會產生該公差。請與零件製造商聯繫，以確保（合理地）可以達到更嚴格的公差，或者以何種成本實現。每個尺寸（位置，孔的大小，角度等）都必須具有公差，公差可以在圖紙上明確說明，也可以作為圖紙上整體符號的一部分。 \n 4.8.7 Inspection Dimensions (Critical Dimensions) (檢驗尺寸（關鍵尺寸）) \n Parts can have hundreds of dimensions. To fully specify every feature on some parts takes a fair amount of time. Historically, every feature on a drawing was dimen-sioned to enable that feature to be inspected and found either in compliance with the specification (drawing) or non-compliant. With the advent of 3D CAD systems for designing and creating drawing documentation, it is completely possible to transfer all of the part information digitally, without any dimensions being specified actually on the drawing, and have that part manufactured at the “nominal specified dimen-sion.” That is, features that are 3.000 inches apart are “drawn” exactly 3.000 inches apart, and that number is an integral part of a file that the part manufacturer gets.Anyone who brings up that part file on their CAD system can query that file and see those features need to be 3.000 inches apart (with a stated tolerance as a part of the CAD file). In fact, inspection departments, if they had access to the CAD file, could inspect the part \n 零件可以具有數百個尺寸。要完全指定某些零件上的每個功能需要花費大量時間。從歷史上看，對圖紙上的每個特徵都進行了尺寸標註，以便可以檢查和發現該特徵是否符合規範（圖紙）或不符合規範。隨著3D CAD系統的出現 設計和創建工程圖文檔時，完全有可能以數字方式傳輸所有零件信息，而無需在工程圖上實際指定任何尺寸，而使零件以“標稱指定尺寸”進行製造。也就是說，相隔3.000英寸的要素將精確地“繪製” 3.000英寸 零件號是零件製造商獲取的文件的組成部分。在其CAD系統上顯示該零件文件的任何人都可以查詢該文件，並看到這些特徵需要相距3.000英寸（以規定的公差作為單位）。 CAD文件的一部分）。實際上，檢查部門如果可以訪問CAD文件，則可以檢查零件', 'tags': '', 'url': 'Assignment 2.html'}]};