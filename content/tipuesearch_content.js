var tipuesearch = {"pages": [{'title': 'About', 'text': 'Repository ： https://github.com/s40723144/cd2020 \n Website： https://s40723144.github.io/cd2020/content/index.html \n Group\xa0Repository： https://github.com/s40723150/cd2020ag2 \n Group Presentation： https://s40723150.github.io/cd2020ag2/reveal \n Group Website： https://s40723150.github.io/cd2020ag2 \n', 'tags': '', 'url': 'About.html'}, {'title': '紀錄', 'text': '', 'tags': '', 'url': '紀錄.html'}, {'title': 'w3', 'text': '可攜系統更新python3.8.2 \n \n', 'tags': '', 'url': 'w3.html'}, {'title': 'w7', 'text': '直播測試 \n 利用obs串流yt拍直播影片 \n \n 翻譯Assignment1.2和編輯個人簡介 \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'w8', 'text': '期中影片學習報告 \n', 'tags': '', 'url': 'w8.html'}, {'title': 'w9.10', 'text': '學習如何使用CoppeliaSim \n \n 了解CoppeliaSim主要由模型和場景組成，而場景又細分成環境、腳本等等，同樣模型主要是實體的運用等等。除了這些還有作一些簡單的操作 \n \n \n \n', 'tags': '', 'url': 'w9.10.html'}, {'title': 'Assignment 1', 'text': '', 'tags': '', 'url': 'Assignment 1.html'}, {'title': 'CoppeliaSim User Manual', 'text': '', 'tags': '', 'url': 'CoppeliaSim User Manual.html'}, {'title': 'User interface(用戶界面)', 'text': 'The CoppeliaSim application is composed by several elements. Its main elements are: \n CoppeliaSim應用程序由幾個元素組成。 它的主要元素是： \n \n \n a console window: \xa0under Windows, when the CoppeliaSim application starts, a console window is created but directly hidden again. \n \n window控制台： 在Windows下，當CoppeliaSim應用 程式啟動時 ，會 創建一個控制台窗口 ，但會直接將其隱藏。 \n \n \xa0 an application window: \xa0the application window is the application\'s main window. It is used to display, edit, simulate and interact with a scene. \n \n window應用程式： 應用程式窗口是應用程式的主窗口。它用於 顯示、編輯模擬 並與場景交互。 \n \n several dialogs:\xa0 next to the application window, the user can also edit and interact with a scene by adjusting dialog settings or parameters.\xa0 \n \n 幾個對話框： 在應用程序窗口旁邊，用戶還可以通過 調整對話框的設置或參數 來編輯和與場景進行交互。 \n \n Following illustrates a typical view of the CoppeliaSim application: \n 以下是CoppeliaSim應用程序的典型視圖： \n \n \n When you launch the CoppeliaSim application, CoppeliaSim will initialized one default scene. The user is free to open several scenes in parallel.\xa0 \n In following section, a brief description will be given of the application window\'s elements. \n 當您啟動CoppeliaSim應用程序時，CoppeliaSim將初始化一個默認場景。 用戶可以自由地並行打開多個場景。 \n 在下一節中，將簡要介紹上圖應用程序窗口的元素。 \n \n \n application bar:  the application bar indicates the type of license of your CoppeliaSim copy, the filename of the scene that is currently being displayed, the time used for one rendering pass (one display pass), and the simulator\'s current state (simulation state or type of the active edit mode).\xa0Supported files include "*.ttt"-files (CoppeliaSim scene files) and "*.ttm"-files (CoppeliaSim model files). \n \n 應用程序欄： 應用程序欄指示您的 CoppeliaSim副本的許可類型，當前正在顯示的場景的文件名 ，一次解釋過程（一次顯示過程）所用的時間以及模擬器的當前狀態（模擬狀態或活動活動類型的編輯模式）。支持的文件包括“ *  .ttt”文件 （CoppeliaSim 場景文件 ）和“ * .ttm”文件（CoppeliaSim 模型文件 ）。 \n \n menu bar:  the menu bar allows accessing almost all functionalities of the simulator. Most of the time, the items in the menu bar activate a dialog. The menu bar content is context-sensitive (i.e. it will depend on the current state of the simulator). Most functions in the menu bar can also alternatively be accessed through a popup menu, a double-click on an icon in the scene hierarchy view, or through a click of a toolbar button. \n \n 菜單欄： 菜單欄 允許進入模擬器的幾乎所有功能 。 大多數時候，菜單欄中的項目會激活一個對話框。 菜單欄的內容是上下文相關的（即，它將取決於模擬器的當前狀態）。 也可以通過 彈出菜單 ，或者 雙擊場景階層 視圖中的圖標又或者 單擊工具欄按鈕 來進入菜單欄中的大多數功能。 \n \n toolbars:  the toolbars present functions that are often accessed (e.g. changing the navigation mode, selecting another page, etc.). Some functions in toolbar 1, and all functions in toolbar 2 can also be accessed through the menu bar or popup menu. See further down for more details. Both toolbars can be docked and undocked, but docking works only with their respective initial positions. Following figure explains each toolbar button\'s function: \n \n 工具欄： 工具欄提供經常進入的功能 （例如，更改導航模式，選擇其他頁面等）。  工具欄1 中的某些功能以及 工具欄2 中的所有功能也可以通過菜單欄或彈出菜單進入。 進一步了解更多細節。  這兩個工具欄都可以停靠任務和取消停靠任務 ，但是停靠任務僅適用於它們各自的初始位置。 下圖說明了每個工具欄按鈕的功能： \n \n \n model browser:  the model browser is visible by default, but can be toggled with its corresponding toolbar button. It displays in its upper part a CoppeliaSim model folder structure, and in its lower part, thumbnails of models contained in the selected folder. Thumbnails can be dragged-and-dropped into the scene to automatically load the related model. Caught thumbnails appears dark if the drop area is not supported or not appropriate. \n \n 模型瀏覽器： 默認情況下，模型瀏覽器是可見的，但可以使用其相應的工具欄按鈕進行切換。 它的 上部顯示CoppeliaSim模型結構的文件夾，下部顯示所選文件夾中包含的模型縮略圖 。 可以將縮略圖拖放到場景中以自動加載相關模型。 如果 拖放區域不受支持或不合適，則捕獲的縮略圖將顯示為黑色 。 \n \n \n \n scene hierarchy: the scene hierarchy is visible by default, but can be toggled with its corresponding toolbar button. It displays the content of a scene (i.e. all scene objects composing a scene). Since \xa0 scene objects \xa0 are built in a hierarchy-like structure, the scene hierarchy displays a tree of this hierarchy, and individual elements can be expanded or collapsed. A double-click on an icon opens/closes a property dialog related to the clicked icon. A double-click on an object name allows editing it. The mouse wheel as well as a drag of the scene hierarchy view\'s scrollbars allows shifting the content up/down or left/right. Control and shift selection is always supported. Objects in the scene hierarchy can be dragged and dropped onto another object, in order to create a parent-child relationship. The scene hierarchy will display a different content if the simulator is in an edit-mode state. Refer to the \xa0 shape edit modes , and the \xa0 path edit mode \xa0 for more information. \n \n \n 場景層次結構： 默認情況下，場景層次結構是可見的，但可以使用其相應的工具欄按鈕進行切換。 它顯示場景的內容（即組成場景的所有場景對象）。 由於場景對像是按類似層次結構的結構構建的，因此 場景層次結構將顯示此層次結構的樹狀圖，並且各個元素都可以展開或折疊。 雙擊圖標可打開/關閉與單擊的圖標相關的屬性對話框。 雙擊對象名稱可以對其進行編輯 。 鼠標滾輪以及場景層次結構視圖的拖動允許向上/向下或向左/向右移動內容。 始終支持控制和換檔選擇。  可以將場景層次結構中的對象拖放到另一個對像上，以創建鄰接表模型 。 如果模擬器處於編輯模式狀態，則場景層次將顯示不同的內容。 有關更多信息，請參考形狀編輯模式和路徑編輯模式。 \n \n \n page:   each \xa0 scene \xa0 may contain up to 8 pages, each of them may contain an unlimited number of views. A page can be seen as container for views. Refer to the \xa0 pages and views section \xa0 for more details. \n \n 頁面： 每個場景最多可包含8個頁面 ，每個頁面可包含不限數量的視圖。可以將頁面視為視圖的容器。請參閱頁面和視圖部分以獲取更多詳細信息。 \n \n views:   there can be an unlimited number of views contained in a page. A view is used to display the scene (itself containing an environment and objects), seen through a \xa0 viewable object \xa0 (e.g. \xa0 cameras , \xa0 graphs \xa0 or \xa0 vision sensors ). \n \n 視圖： 頁面中可以包含無數個視圖。 視圖用於顯示通過可見對象 （例如攝像機，圖形或視覺傳感器） 看到的場景 （本身包含環境和對象）。 \n \n information text:  the information text displays information related to current object/item selection and to running simulation states or parameters. The text display can be toggled with one of the two small buttons on the upper left side of a page. The other button can be used to toggle a white background, giving a better contrast depending on the background color of a scene. \n \n 信息文本： 信息文本顯示與當前對象/項目選擇以及運行模擬狀態或參數有關的信息。可以使用頁面 左上方的兩個小按鈕之一來切換文本顯示。另一個按鈕可用於切換白色背景 ，根據場景的背景顏色提供更好的對比度。 \n \n status bar: \xa0 the status bar displays information related to performed operations, commands, and also displays error messages from the Lua interpreter. From within a\xa0 script \xa0the user can also output strings to the status bar with the\xa0 sim.addStatusbarMessage \xa0function. The status bar displays only two lines by default, but it can be resized using its horizontal separation handle. \n \n 狀態欄： 狀態欄 顯示與執行的操作，命令有關的信息 ，還顯示來自Lua解釋器的錯誤消息 。用戶還可 以從腳本中使用\xa0 (sim.addStatusbarMessage)\xa0 函數將字符串輸出到狀態欄 。默認情況下，狀態欄僅顯示兩行，但可以使用其水平分隔手柄調整其大小。 \n \n Lua commander:   a read-eval-print loop, that adds a text input to the CoppeliaSim status bar, allowing to enter and execute Lua code on the fly, like in a terminal. The code can be run in \xa0 the sandbox script , or any other active script in CoppeliaSim. \n \n Lua指令： 一個讀-評估-打印循環 ，它將文本輸入添加到CoppeliaSim狀態欄，從而可以像在終端機中一樣快速輸入和執行Lua代碼。 該代碼可以在沙盒腳本或CoppeliaSim中的任何其他活動腳本中運行。 \n \n custom user interfaces: \xa0 custom user interfaces \xa0are user-defined UI surfaces that can be used to display information (text, images, etc.) or a custom dialog, allowing to interact with the user in a customized way. \n \n 自定義用戶界面： 自定義用戶界面是用戶定義的UI表面，可用於顯示信息（文本，圖像等）或自定義對話框 ，從而允許以自定義方式與用戶進行交互。 \n \n popup menu:  popup menus are the menus that appear after a right mouse button click. To activate a popup menu, make sure the mouse doesn\'t move during the click operation, otherwise the camera rotation mode may be activated (see the  camera section \xa0for more details). Each surface within the application window (e.g. scene hierarchy view, page, view, etc.) may trigger a different popup menu (context-sensitive). The content of popup menus may also change depending on the current simulation state or edit mode. Most popup menu function can also be accessed through the menu bar, except for the view-menu item that only appears when the popup menu is activated on a view or page. \n \n 彈出菜單：彈出菜單是單擊鼠標右鍵後出現的菜單。要激活彈出菜單，請確保在單擊操作期間鼠標沒有移動，否則可能會激活相機旋轉模式（有關更多詳細信息，請參見相機部分）。應用程序窗口內的每個表面（例如，場景層次視圖，頁面，視圖等）可能會觸發不同的彈出菜單（上下文相關）。 彈出菜單的內容可能根據當前的模擬狀態或編輯模式而改變。除了僅在視圖或頁面上激活彈出菜單時才會顯示的視圖菜單項，大多數彈出菜單功能也可以通過菜單欄進入。 \n', 'tags': '', 'url': 'User interface(用戶界面).html'}, {'title': 'Scenes and models(場景和模型)', 'text': 'Scenes and models are CoppeliaSim\'s main simulation elements. A model is a sub-element of a scene, clearly marked as model. A scene may contain any number of models. Following figure illustrates the scene-model relationship: \n 場景和模型是CoppeliaSim的主要模擬元素。  模型是場景的子元素，明確標記為模型。 場景可以包含任何數量的模型。  下圖說明了場景模型關係： \n \n Scenes(場景) \n Compared to\xa0 models , a scene can contain exactly the same type of elements, but additionally also includes following elements, specific to scenes: \n 與模型相比，場景可以包含完全相同類型的元素，但另外還包括以下特定於場景的元素： \n \n \n \n The environment \n The main script \n Pages and views \n \n \n \n \n \n \n \n 環境 \n 主要腳本 \n 頁面和視圖 \n \n \n A scene or scene image content can be seen through a\xa0 viewable object \xa0 associated with a view, itself contained in a \xa0 page . When creating a new scene ([Menu bar --> File --> New Scene]), the default scene will contain following elements: \n 可以通過與視圖相關聯的可視對象（本身包含在頁面中）來查看場景或場景圖像內容。創建新場景時（ [菜單欄->文件->新場景] ），默認場景將包含以下元素： \n \n \n Several\xa0 camera objects :  cameras allow to \xa0 see \xa0 the scene if they are associated with a view. \n Several\xa0 light objects :  without a light the scene would be hardly visible. The light is used to illuminate the scene. \n Several\xa0 views :  a view is associated with a camera and displays what the camera \xa0 sees . Views are contained in pages. \n Several\xa0 pages :  a page contains one or several views. \n The environment :  the environment is composed by properties as ambient light, fog, background color, etc. \n The floor:  the floor is made-up by\xa0 objects \xa0 grouped in a model. \n The default\xa0 main script :  the default main script should allow running minimal simulations, without the need of \xa0 child scripts . A child script copied into the scene at a later stage will then also be automatically executed (called by the main script) if it is associated with a scene object. \n \n \n 幾個攝影機對象： 如果攝影機與視圖關聯，則可以查看場景。 \n 幾個燈光對象： 沒有燈光，幾乎看不到場景。燈光用於照亮場景。 \n 幾個視圖： 一個視圖與相機關聯，並顯示相機看到的內容。視圖包含在頁面中。 \n 多個頁面： 一個頁麵包含一個或多個視圖。 \n 環境： 環境由環境光，霧，背景色等屬性組成。 \n 地板： 地板是由模型中分組的對象組成的。 \n 默認主腳本： 默認主腳本應允許運行最少的模擬，而無需子腳本 。如果子腳本與場景對象相關聯，則在稍後階段複製到場景中的子腳本也將自動執行（由主腳本調用）。 \n \n \n Scenes can be opened (loaded) with [Menu bar --> File --> Open Scene...] and saved with [Menu bar --> File --> Save Scene] or [Menu Bar --> File --> Save Scene as...]. Scene files ("*.ttt"-files) also support drag and drop operations between the explorer window and the application window. Scene files can also be double-clicked, in which case they will launch the CoppeliaSim application and be opened. \n 可以使用 [菜單欄->文件->打開場景...]打開（加載）場景，並使用[菜單欄->文件->保存場景]或[菜單欄->文件- >將場景另存為...]。 場景文件（“ * .ttt”文件） 還支持資源管理器窗口和應用程序窗口之間的拖放操作。 也可以雙擊場景文件，在這種情況下，它們將啟動CoppeliaSim應用程序並打開。 \n Switching between opened scene can be achieved with a single click in the upper part of the \xa0 scene hierarchy \xa0 (all opened scenes are grouped at the top of the scene hierarchy), or by using the scene selector via its related toolbar button: \n 只需在場景階層結構的上部單擊即可 切換打開的場景 （所有打開的場景都在場景階層結構的頂部分組），或者通 過與其相關的工具欄按鈕使用場景選擇器 來實現： \n \n model(模型) \n A model is a sub-element of a\xa0 scene . A model by itself cannot exist, except in a file ("*.ttm"-file type), nor can it be simulated by itself. A model has to be contained in a scene in order to be operational. \n 模型是場景的子元素。 除了文件（ “ * .ttm”-文件類型 ）外， 模型本身不能存在，也不能通過自身進行模擬。 模型必須包含在場景中才能運行。 \n Models are defined by a selection of\xa0 scene objects \xa0 built on a same hierarchy tree, where the base of the tree has to be an object flagged as \xa0 object is model base . They can be loaded with [Menu bar --> File --> Load model...]. It is however much easier and convenient to load a model with a drag-and-drop operation between the \xa0 model browser \xa0 and a \xa0 scene view . Models can be saved with [Menu bar --> File --> Save model as...], just make sure one single object flagged as \xa0 object is model base \xa0 is selected, otherwise the \xa0 Save model as... -menu item will not be enabled. Make also sure to follow the \xa0 tutorial on how to build a clean simulation model . \n 通過在同一階層樹 狀圖上構建的場景對象的選擇來定義模型，其中樹狀圖的基礎必須是已標記對像是模型基礎的對象。\xa0 可以通過[菜單欄->文件->加載模型...]加載它們。 但是，通過在模型瀏覽器和場景視圖之間進行拖放操作來加載模型更加容易和方便。 可以使用[菜單欄->文件->將模型另存為...]保存模型，只需要確認已標註的單個對象是不是選擇的基礎模型 ，否則將模型另存為...-菜單項 未啟用(沒辦法)。 還請確保遵循有關如何構建清晰仿真模型的教程。 \n A model is defined in following steps: \n 通過以下步驟定義模型： \n \n \n attach all objects that logically belong to the model to a base object, so that the base object is the base of the model tree. \n \n 將邏輯上屬於模型的所有對象附加到基礎對象 ，以便基礎對像是模型樹狀圖的基礎。 \n \n check the\xa0 object is model base -item in the   \xa0 object common properties . \n \n 在通用屬性中檢查對象是不是模型基礎項目 \n \n in the same dialog as above, check the\xa0 object/model can transfer or accept DNA -item. This will simplify model re-instanciation if you modify it at a later stage. \n \n 在與上述相同的對話框中， 檢查對象/模型是否可以轉移或接受DNA項目 。 如果稍後進行修改，這將簡化模型的重新實例化。 \n \n in the same dialog as above, clicking\xa0 Edit model properties , you can define special overriding properties (e.g. make the whole model invisible, non-collidable, etc.). That allows to quickly disable some properties for all objects defined in the model. \n \n 在與上述相同的對話框中， 點擊編輯模型屬性，您可以定義特殊的替代屬性（例如，使整個模型不可見，不碰撞等） 。 這樣可以快速禁用模型中定義的所有對象的某些屬性。 \n \n for all objects in the model, except for the base object, check the\xa0 select base of model instead -item in the  \xa0 object common properties . This will protect your model: you won\'t be able to directly select individual objects in your model, and you will be able to manipulate your model almost as a single object. \n \n 對於模型中的所有對象（基礎對象除外），請 檢查對象通用屬性中的模型選擇基礎代替項目 。 這將保護您的模型： 您將無法直接選擇模型中的單個對象，並且幾乎可以將其作為單個對象來操作模型。 \n \n for all objects that are normally not visible, check the\xa0 Don\'t show as inside model selection -item. This will make the model bounding box appear in the right size around the model. \n \n 對於通常不常見的所有對象，請選中“不顯示內部模型”選擇項 。 這將使模型邊界框在模型周圍以正確的尺寸顯示。 \n \n think about the role of the model: will you be able to attach it to some other object? (e.g. your model is a gripper that you could attach to a manipulator wrist). Or will you be able to attach some other model to it? (e.g. your model is a manipulator that could accept a gripper model). Once the role is decided, define the model\'s\xa0 assembling behaviour . Refer also to this \xa0 dynamics design consideration . \n \n 考慮一下模型的作用： 您能否將其附加到其他對像上？ （例如，您的模型是可以連接到機械手腕上的抓手）。 還是可以附加一些其他模型？ （例如，您的模型是可以接受機械手模型的操縱器）。  確定角色後，定義模型的組裝行為。   另請參閱此動力學設計注意事項。 \n \n Now, individual objects build on the model base cannot be selected anymore in the scene (selecting them will select the base of the model instead), however they can still be individually selected by holding down the ctrl- and shift-key during selection, or by selecting them in the \xa0 scene hierarchy . In addition to that, when the base object is selected, a stippled bounding box encompassing the whole model is displayed as can be seen in following figure: \n 現在，無法在場景中選擇建立在模型基礎上的單個對象（選擇它們將改為選擇模型的基礎），但是仍然 可以通過在選擇過程中按住ctrl和Shift鍵來單獨選擇它們，或者 通過在場景層次中選擇它們。 除此之外，當選擇基礎對象時，將顯示一個包圍整個模型的點畫邊界框 ，如下圖所示： \n \n Notice the model tag on the left-hand side of the icon of the object flagged as model base: \n 注意標記為模型庫的對像圖標左側的模型標籤： \n \n A double-click on a model tag opens the \xa0 model dialog , where model properties can be adjusted. It is also good practice to collapse a model\'s hierarchy once the model was edited in order to easily identify the number of logically grouped elements/models: \n 雙擊模型標籤可打開模型對話框，可在其中調整模型屬性。  修改模型的階層結構後，就是還不錯折疊模型的階層結構，以輕鬆識別邏輯分組的元素/模型的數量： \n \n Grouping several objects as a model is also important when a\xa0 child script \xa0 accesses the objects programmatically; remember that in CoppeliaSim, objects/models can be duplicated at any time, also during a simulation. In order for the duplicated child script to be able to access the correct objects (not the original objects but the duplicated objects), the child script should always be duplicated at the same time as the objects it accesses. One way to guaranty that is to create a model (as described above) and to make sure the child scripts that access objects in the model are associated with objects that are contained in the model. Best is to associate one child script (there might be secondary child scripts too) with the the base of the model. Refer to the \xa0 accessing objects programmatically section \xa0 for more information. \n 當子腳本以編程方式進入對象時，將多個對象分組成模型也很重要 。 請記住，在CoppeliaSim中，對象/模型可以隨時復制，甚至在模擬過程中也可以復制。  為了使復制的子腳本能夠進入正確的對象 （不是原始對象，而是複制的對象），應始終 在進入子腳本的同時復制子腳本。 保證的一種方法是 創建模型 （如上所述）， 並確保進入模型中對象的子腳本與模型中包含的對象相關聯 。最好是基礎的模型與子腳本（也可能有第二個子腳本）相關聯。 有關更多信息，請參考以編程方式 進入 對象部分。 \n In order for models to be easily combined (i.e. built on top of each other) without any additional modification, it is important to consider what role the model will be playing: will it be dynamically simulated? Will it be attached to other models, or will it accept other models attached to it? The answer to those questions will allow you to select the best object type to work as a model base. Refer to the\xa0 section on designing dynamic simulations \xa0 for more information. \n 為了使模型易於組合（即彼此構建）而無需進行任何其他修改，重要的是要 考 慮模型將扮演什麼角色：可以動態模擬嗎？ 它會被附加到其他型號，還是會接受其他附加模型？   這些問題的答案將使您能夠選擇最佳的對像類型作為模型基礎。  有關更多信息，請參考設計動態仿真部分。 \n Copy and pasting a model behaves exactly like saving the model, then loading it (using however a memory buffer instead of the disk space). Models can be copied from one scene to another like any other object. Model files ("*.ttm"-files) also support drag-and-drop operations between the explorer window and the application window. Model files can also be double-clicked, in which case they will launch the CoppeliaSim application and be loaded into a default scene. \n 複製和粘貼模型的行為其實很像是在保存模型，然後加載 （完全使用內存緩衝區而不是磁盤空間）。 可以像其他任何對像一樣將模型從一個場景複製到另一個場景。  模型文件（“ * .ttm”文件）還支持資源管理器窗口和應用程序窗口之間的拖放操作。 還可以雙擊模型文件，在這種情況下，它們將啟動CoppeliaSim應用程序並加載到默認場景中。 \n The properties of a model can be individually adjusted in the \xa0 model dialog . \n 可以在模型對話框中單獨調整模型的屬性。 \n Model dialog(模型文字框) \n The properties of a model can be individually adjusted in the model dialog. It can be opened with a double-click on a model icon in the \xa0 scene hierarchy : \n 可以在模型對話框中單獨調整模型的屬性。 可以雙擊場景層次中的模型圖標來打開它： \n \n Some of above objects can have special properties allowing other objects or \xa0 calculation modules \xa0 to interact with them. Objects can be: \n 以上某些對象可以具有特殊的屬性，從而允許其他對像或計算模塊與它們進行交互。對象可以是： \n \n Collidable : collidable objects can be tested for \xa0 collision \xa0 against other collidable objects. \n Measurable : measurable objects can have the \xa0 minimum distance \xa0 between them and other measurable objects calculated. \n Detectable : detectable objects can be detected by \xa0 proximity sensors . \n Renderable : renderable objects can be \xa0 seen \xa0 or \xa0 detected \xa0 by \xa0 vision sensors . \n Viewable : viewable objects can be \xa0 looked through , \xa0 looked at , or their image content can be visualized in views. Refer to the \xa0 pages and views-section \xa0 for more information \n \n \n 可碰撞的： 可以測試可碰撞的物體與其他可碰撞物體的碰撞。 \n 可測量的： 可測量的對象與所計算的其他可測量對象之間的距離最小。 \n 可檢測的： 可檢測的物體 可以被接近傳感器檢測到。 \n 可渲染： 視覺傳感器可以看到或檢測可渲染對象 。 (渲染的意思:在我們假象的三维空間中，但是我們要在二维的顯示器中看到他，我們就稱之為把三角形從三维空間渲染到二维空間中 。) \n 可視對象： 可以查看，查看可視對象，或者可以在視圖中可視化其圖像內容。請參閱頁面和視圖部分以獲取更多信息 \n \n \n \n Select model thumbnail : when saving a model, a dialog pops open asking for a model thumbnail (that will be displayed in the \xa0 model browser ). If however you wish to save a thumbnail of your model in a different configuration (e.g. you wish to save a model of a snake robot in straight configuration, but you want the thumbnail to visualize the snake robot in a bent configuration), then you can specify the thumbnail here. \n \n 選擇模型縮略圖： 保存模型時，會彈出一個對話框，要求您提供模型縮略圖（將在模型瀏覽器中顯示）。但是，如果 您希望以其他配置保存模型的縮略圖（例如，希望以直線配置保存蛇形機器人的模型，但是希望縮略圖以彎曲的形態可視化蛇形機器人），則可以在此處指定縮略圖。 \n \n Override properties : here you can disable (override) specific properties for the whole model (i.e. for all objects in the model hierarchy tree). This is convenient to quickly disable a model that takes too much calculation time for instance. See also the sections on \xa0 collidable objects , \xa0 measurable objects , \xa0 renderable objects \xa0 and \xa0 detectable objects , and the \xa0 sim.setModelProperty API function . \n \n 覆蓋屬性： 您可以在此處為整個模型（即模型層次結構樹中的所有對象）禁用（覆蓋）特定屬性。例如，這可以方便地快速禁用需要太多計算模型的時間。 另請參見有關可碰撞對象，可測量對象，可呈現對象和可檢測對象的部分，以及sim.setModelProperty API函數。 \n \n Model content acknowledgments/Info : information related to a model. It is always good practice to acknowledge the original author of a model, or imported mesh. When a model that contains acknowledgment information is opened, it will automatically display that information. \n \n 模型內容確認/信息： 與模型有關的信息。  確認模型的原始作者或導入的網格物體始終是一種好習慣。 當包含確認信息的模型打開時，它將自動顯示該信息。 \n', 'tags': '', 'url': 'Scenes and models(場景和模型).html'}, {'title': 'Environment(環境)', 'text': "The environment in CoppeliaSim defines properties and parameters that are part of a\xa0 scene , but that are not \xa0 scene objects . Environment properties and parameters are not saved when a \xa0 model \xa0 is saved, but only when a scene is saved. \n CoppeliaSim中的環境定義了屬於場景但不屬於場景對象的屬性和參數 。   保存模型時，沒辦法保存環境屬性和參數，但只有在保存場景時可以保存。 \n An environment defines following properties and parameters: \n 環境定義以下屬性和參數： \n \n \n Background colors. \n Fog parameters. Fog parameters are not directly interacting with scene objects, except with \xa0 cameras \xa0 or \xa0 vision sensors \xa0 if the corresponding option was selected. \n Ambient light \n Scene creation information \n Additional settings \n \n \n 背景顏色。 \n 霧參數。 除已選擇相應選項的攝像機或視覺傳感器外，霧參數不會直接與場景對象交互。 \n 環境光 \n 場景創建信息 \n 其他設置 \n \n \n \n Environment dialog(環境文字框) \n The environment dialog can be accessed with [Menu bar --> Tools --> Environment] or by double-clicking following icon in the \xa0 scene hierarchy : \n 可以使用 [菜單欄->工具->環境] 或通過雙擊場景階層結構中的以下圖標來打開環境對話框： \n \n \n Background (up / down) : allows adjusting the background color of a scene. The up component corresponds to the upper part of the screen (sky), the down component corresponds to the lower part of the screen. The background colors are only visible when the fog functionality is disabled. \n \n 背景（上/下）： 允許調整場景的背景色。 向上部分對應於屏幕的上部（天空），向下部分對應於 屏幕的下部。僅當禁用霧功能時，背景色才可見。 \n \n Ambient light : allows adjusting the ambient light of a \xa0 scene . The ambient light can be seen as the minimal light of a scene, it illuminates an object in the exact same way from all directions. See the \xa0 section about lights \xa0 for more details about illumination of a scene. \n \n 環境光： 可以調整場景的環境光。 可以將環境光視為場景的最小光，它 從各個方向以完全相同的方式照亮對象。 有關場景照明的更多詳細信息，請參見關於燈光的部分。 \n \n Adjust fog parameters : allows to adjust various fog parameters. \n \n 調整霧參數：允許調整各種霧參數。 \n \n Maximum triangle size (absolute) : this item will not affect the visual appearance of \xa0 shapes . It will however affect the execution speed of most CoppeliaSim \xa0 calculation modules . When performing \xa0 minimum distance calculations \xa0 for instance, between two \xa0 entities , execution will generally be faster if both entities are composed by similar-sized triangles. The maximum triangle size value specifies how the internal representation of a \xa0 shape \xa0 is handled (i.e. how elaborate the shape's calculation structure is). Small sizes will increase the preprocessing time, but generally the simulation execution speed will be increased at the same time. This value sets the overall maximum triangle size, as an absolute value. See also next item and the \xa0 reduce triangle size -item in the \xa0 triangle edit mode . \n \n 最大三角形尺寸（絕對值）： 此項不會影響形狀的外觀。但是，它將 影響大多數CoppeliaSim計算模塊的執行速度。 例如， 在兩個實體之間執行最小距離計算時，如果兩個實體都由大小相似的三角形組成，則執行速度通常會更快。最大三角形尺寸值指定如何處理形狀的內部表示形式（即，形狀的計算結構的詳細程度）。小尺寸將增加預處理時間，但是通常仿真執行速度會同時提高。 此值將整體最大三角形大小設置為絕對值。另請參見下一項和在三角形編輯模式下的縮小三角形尺寸項目。 \n \n Minimum triangle size (relative) : similar to previous item, but this item helps avoiding creating too large calculation structures that might potentially take very long. This value sets the minimum triangle size, as a relative value (relative to a given object's largest dimension). \n \n 最小三角形尺寸（相對）： 與上一個項目相似，但該項目有助於避免創建太大的計算結構 ，而這可能會花費很長時間。 此值將最小三角形尺寸設置為相對值（相對於給定對象的最大尺寸）。 \n \n Save operation also saves existing calculation structures : for \xa0 distance calculations , \xa0 collision detections , etc. a data structure is computed at the beginning of a simulation (preprocessing), or the first time a \xa0 shape \xa0 is involves in such calculations, in order to speed-up calculations. Calculation of that data structure might be time consuming, so the user can chose to save it together with the \xa0 scene \xa0 or \xa0 model . However one has to be aware that the additional information that will be saved is large and will result in larger files (sometimes twice as large or more). \n \n 保存操作還會保存現有的計算結構： 用於距離計算，碰撞檢測等。 在模擬（預處理）開始時或第一次涉及形狀以加快速度時，會計算數據結構計算。計算該數據結構可能很耗時，因此用戶可以選擇將其與場景或模型一起保存。 但是，必須注意，將要保存的附加信息很大，並且會導致文件更大（有時是兩倍或更多）。 \n \n Shape textures disabled : if selected, then all \xa0 textures \xa0 applied to shapes will be disabled. \n \n 禁用形狀紋理： 如果選中，則將禁用應用於形狀的所有紋理。 \n \n Lock scene after next scene save : select this item if you want to lock your scene from edition/modification, script content viewing and resource export. After next scene save operation, the scene will be locked. Make sure you have saved the same scene in an unlocked state if you want to be able to modify it at a later time. \n \n 下一個場景保存後鎖定場景： 如果要從版本/修改，腳本內容查看和資源導出中鎖定場景，請選擇此項目。下一個場景保存操作後，場景將被鎖定。 如果希望以後可以修改同一場景，請確保已將其保存為未鎖定狀態。 \n \n Extension string : a string that describes additional environment properties, mainly used by extension plugins (see also the \xa0 sim.getExtensionString \xa0 API function). \n \n 擴展字符串： 描述附加環境屬性的字符串，主要由擴展插件使用 （另請參見sim.getExtensionString API函數）。 \n \n Clean-up object names : allows putting some order into object names with a hash tag. This is not necessary, but might be convenient to reduce the suffix numbers after the hash tags. \n \n 清理對象名稱： 允許使用主題標籤將一些順序放入對象名稱中 。 這不是必需的，但是可以方便地減主題標記後的後綴數。 \n \n Clean-up ghosts : removes all ghost objects a scene might contain. Refer also to the \xa0 ghost recording functionality . \n \n 清理重影： 刪除場景中可能包含的所有重影對象。 另請參閱幻像錄製功能。 \n \n Scene content acknowledgements / Info : information related to a scene. It is always good practice to acknowledge the original author of a scene, \xa0 model , or imported mesh. When a scene that contains acknowledgment information is opened, it will automatically display that information. \n \n 場景內容確認/信息： 與場景相關的信息。 最好先確認場景，模型或導入的網格的原始作者。當一個包含確認信息的場景被打開時，它將自動顯示該信息。 \n", 'tags': '', 'url': 'Environment(環境).html'}, {'title': 'Entities(實體)', 'text': "An entity is a term that refers to a \xa0 scene object \xa0 or a \xa0 collection . Following figure illustrates the relationship between scene objects, collections and entities: \n 實體是指場景對像或集合的術語。  下圖說明了場景對象，集合和實體之間的關係： \n \n Scene objects(場景對象) \n The main elements in CoppeliaSim that are used for building a simulation\xa0 scene \xa0are scene objects (objects in short). Objects are visible in the\xa0 scene hierarchy \xa0and in the scene \xa0view . In the scene view, objects have a three dimensional representation as illustrated in following figure: \n CoppeliaSim中用於構建模擬場景的主要元素是場景對象（簡稱對象）。 對像在場景階層結構和場景視圖中可見。  在場景視圖中，對象具有三維表示，如下圖所示： \n \n Following list gives a brief functional description of each object type: \n \n \n Shapes : a shape is a rigid mesh that is composed of triangular faces. \n Joints : a joint object is a joint or actuator. Four types are supported: revolute joints, prismatic joints, screws and spherical joints. \n Graphs : a graph is used to record and visualize simulation data. \n Dummies : a dummy is a point with orientation. Dummies are multipurpose objects that can have many different applications. \n Proximity sensors : a proximity sensor detects objects in a geometrically exact fashion within its detection volume. CoppeliaSim supports pyramid-, cylinder-, disk-, cone- and ray-type proximity sensors. \n Vision sensors : a vision sensor is a camera-type sensor, reacting to light, colors and images. \n Force sensors : a force sensor is an object able to measure forces and torques that are applied to it. It also has the ability to \xa0 break \xa0 if a given threashold is overshot. \n Cameras : a camera is an object that allows \xa0 seeing \xa0 the simulation scene from various view points. \n Lights : a light is an object that allows illuminating the simulation scene. \n Paths : a path is an object that defines a path or trajectory in space. It can be used for various purposes, also as a customized joint or actuator. \n OC trees : an OC tree is a spacial partitioning data structure made up by voxels. \n Point clouds : a point cloud is an OC tree structure that contains points. \n \n \n 形狀： 形狀是由三角形面組成的剛性網格。 \n 軸節： 軸節對像是關節或執行器。支持四種類型：旋轉接頭，棱柱接頭，螺釘和球形接頭。 \n 圖形： 圖形用於記錄和可視化模擬數據。 \n 用來填充的無用物件： 無用物件 是具有定向的點。 無用物件是可以具有許多不同應用程序的多用途對象。 \n 鄰近傳感器： 鄰近傳感器以幾何精確的方式在其檢測範圍內檢測物體 。 CoppeliaSim支持金字塔型，圓柱型，圓盤型，圓錐型和射線型接近傳感器。 \n 視覺傳感器： 視覺傳感器是一種相機型傳感器，對光線，顏色和圖像有反應。 \n 力傳感器： 力傳感器是能夠測量施加到其上的力和扭矩的對象。 如果給定的閾值被超出，它也具有打破的能力。 \n 攝像機： 攝像機是一個對象，可以從各個角度查看模擬場景。 \n 燈光： 燈光是一個可以照亮模擬場景的對象。 \n 路徑： 路徑是在空間中定義路徑或軌蹟的對象。它可以用於各種目的，也可以用作定制的接頭或執行器。 \n 八元樹： 八元樹是由體素組成的空間分區數據結構。 \n 點雲： 點雲是包含點的 八元 樹結構。 \n \n \n Some of above objects can have special properties allowing other objects or \xa0 calculation modules \xa0 to interact with them. Objects can be: \n 以上某些對象可以具有特殊的屬性，從而允許其他對像或計算模塊與它們進行交互。對象可以是： \n \n Collidable : collidable objects can be tested for \xa0 collision \xa0 against other collidable objects. \n Measurable : measurable objects can have the \xa0 minimum distance \xa0 between them and other measurable objects calculated. \n Detectable : detectable objects can be detected by \xa0 proximity sensors . \n Renderable : renderable objects can be \xa0 seen \xa0 or \xa0 detected \xa0 by \xa0 vision sensors . \n Viewable : viewable objects can be \xa0 looked through , \xa0 looked at , or their image content can be visualized in views. Refer to the \xa0 pages and views-section \xa0 for more information \n 可碰撞的： 可以測試可碰撞的物體與其他可碰撞物體的碰撞。 \n 可測量的： 可測量的對象與所計算的其他可測量對象之間的距離最小。 \n 可檢測的： 可檢測的物體 可以被接近傳感器檢測到。 \n 可渲染： 視覺傳感器可以看到或檢測可渲染對象 。 (渲染的意思:在我們假象的三维空間中，但是我們要在二维的顯示器中看到他，我們就稱之為把三角形從三维空間渲染到二维空間中 。) \n 可視對象： 可以查看，查看可視對象，或者可以在視圖中可視化其圖像內容。請參閱頁面和視圖部分以獲取更多信息 \n \n \n Each object has a position and orientation within the simulation scene. We refer to an object's position and orientation as configuration of the object. Objects can be attached to other objects (or built on top of each other). If object A is built on top of object B, then object B is the parent and object A is the child. To create a parent-child relationships between object B and object A, select object A, then select object B (the selection order is important). Then select [Menu bar --> Edit --> Make last selected object parent]. Following figure illustrates this operation: \n 每個對像在模擬場景中都有一個位置和方向。 我們將對象的位置和方向稱為對象的配置。  可以將對象附加到其他對象（或建立在彼此之上）。 如果對象A建立在對象B的頂部，則對象B是父對象，而對象A是子對象。 要在對象B和對象A之間創建父子關係，請選擇對象A，然後選擇對象B（選擇順序很重要）。 然後選擇[菜單欄->編輯->將最後選擇的對象設為父對象]。  下圖說明了此操作： \n \n Alternatively, you can drag and drop an object onto another one in the \xa0 scene hierarchy \xa0 to obtain a similar result. Notice that object A's configuration was not changed (both objects kept their respective configuration). However, looking at the scene hierarchy, you can see that object A became child of object B. If you now move object B, object A will automatically follow, since object A is attached to object B. Object A can be detached by selecting it, then selecting [Menu bar --> Edit --> Make selected object(s) orphan]. Doing so will detach object A without changing its configuration. Alternatively, you can drag and drop an object onto the world icon to obtain a similar result. \n 或者，您可以將一個對象拖放到場景階層結構中的另一個對像上，以獲得相似的結果。(將對象A加入為對象B的子對象)。 請注意，對象A的配置未更改（兩個對像都保留了各自的配置）。但是，查看場景階層結構，您可以看到對象A成為對象B的子對象。如果現在移動對象B，則對象A將自動跟隨，因為對象A已附加到對象B。可以通過選擇對象A來分離對象A。  然後選擇[菜單欄->編輯->使所選對象成為孤立對象]。這樣做將分離對象A而不會更改其配置。或者，您可以將一個對象拖放到上層圖標上以獲得類似的結果。 \n \n \n \n (1)\xa0 \xa0Scene object properties(場景對象屬性) \n The \xa0 scene object \xa0 properties dialog is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the \xa0 scene hierarchy , or with a click on its \xa0 toolbar \xa0 button: \n 場景對象屬性對話框位於 [菜單欄->工具->場景對象屬性] 。 您也可以通過 雙擊場景階層結構中的對像圖標或單擊其工具欄按鈕來打開 對話框： \n \n The scene object properties dialog displays properties related to objects (i.e. \xa0 scene objects ). The dialog is context sensitive and its content will mainly depend on the scene object selection state: only the properties of the last selected object will be displayed. Those properties are divided into 2 parts: \n 場景對象屬性對話框顯示與對象（即場景對象）相關的屬性。  該對話框是上下文相關的，其 內容將主要取決於場景對象的選擇狀態：僅顯示最後選擇的對象的屬性。  這些屬性分為兩部分： \n \n \n \n Object-type specific properties : properties specific to the selected object type. See further below for details. \n Object common properties : properties common to all object types. \n \n \n 特定於對像類型的屬性： 特定於所選對像 類型的屬性。 詳情請參見下文。 \n 對象通用屬性： 所有對像 類型 通用的屬性。 \n \n \n 2 buttons in the upper part of the dialog allow selecting the desired type of properties to display. If the object selection is empty, then all dialog items will be inactive. \n 對話框上部的2個按鈕允許選擇要顯示的所需屬性類型 。  如果對象選擇為空，則所有對話框項都將處於非活動狀態。 \n \n Object common properties(場景對象通用屬性) \n The object common properties dialog is part of the\xa0 scene object properties\xa0 dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the\xa0 scene hierarchy , or with a click on its\xa0 toolbar \xa0button: \n 對象公共屬性對話框是場景對象屬性對話框的一部分，位於 [菜單欄->工具->場景對象屬性] 。 您也可以通過 雙擊場景階層結構中的對像圖標或單擊其工具欄按鈕 來打開對話框： \n \n n the scene object properties dialog, click the \xa0 Common \xa0 button to display the object common properties dialog. The dialog displays the settings and parameters of the last selected \xa0 object . If no object is selected, the dialog is inactive. If more than one object is selected, then some parameters can be copied from the last selected object to the other selected objects ( Apply to selection -buttons): \n 在場景對象屬性對話框中，單擊“通用”按鈕以顯示對象通用屬性對話框。  該對話框顯示最後選擇的對象的設置和參數。 如果未選擇任何對象，則該對話框處於非活動狀態。  如果選擇了多個對象，則可以將某些參數從上一個選定對象複製到其他選定對象 （適用於選擇按鈕）： \n \n \n \n Selectable : indicates whether the object can be selected in the scene. Objects can always be selected in the \xa0 scene hierarchy . Refer also to the \xa0 sim.setObjectProperty \xa0 function. \n \n 可選： 指示是否可以在場景中選擇對象。始終可以在場景階層中選擇對象。 另請參閱sim.setObjectProperty函數。 \n \n Invisible during selection : when enabled, then the object will be invisible for the selection process (i.e. you will be able to select \xa0 through \xa0 the object). \n \n 選擇期間不可見： 啟用該選項後，對象將在選擇過程中不可見（即， 您將可以通過對象進行其他對象選擇 ）。 \n \n Ignored by depth pass : when enabled, then the object will be ignored during the depth rendering pass. The depth rendering pass is used to correctly position the red sphere for camera movements. \n \n 被深度傳遞忽略： 啟用時， 在深度渲染傳遞過程中將忽略該對象。深度渲染傳遞用於正確定位紅色球體以進行相機移動。 \n \n Select base of model instead : if enabled, then selecting the object in the scene will select its first parented object marked as \xa0 object is model base \xa0 instead (see further down). This property is convenient when protecting a model from faulty manipulations, allowing it to be manipulated as a single entity together with other objects. Refer to the \xa0 section on models \xa0 and also to the \xa0 sim.setObjectProperty \xa0 function. \n \n 替代選擇模型基礎： 如果啟用，則在場景中選擇對象將選擇其第一個父對象，標記為“對像是模型基礎” （請參見下一節）。 當保護模型免受錯誤操縱時，此屬性很方便，允許將其與其他對像一起作為單個實體進行操縱。 請參考有關模型的部分以及sim.setObjectProperty函數。 \n \n Ignored by model bounding box : when selected, and the object is part of a \xa0 model , then the model bounding box (i.e. model selection bounding box) will not encompass that object. This is useful for invisible objects that might make the model bounding box appear too big. This property has no functional effect. Refer also to the \xa0 sim.setObjectProperty \xa0 function. \n \n 被模型邊界框忽略： 選中該對象並且該對像是模型的一部分時，模型邊界框（即模型選擇邊界框）將不包含該對象。 這對於可能會使模型邊界框顯得太大的不可見對像很有用。此屬性沒有功能作用。另請參閱sim.setObjectProperty函數。 \n \n Ignored for view-fitting : objects with this item selected will not be taken into account when fitting a scene to a view while no object is selected. Usually floors and similar will be tagged as such. Refer also to the \xa0 view fitting toolbar button \xa0 and to the \xa0 sim.cameraFitToView api function . \n \n 忽略視圖擬合： 在未選擇任何對象的情況下將場景擬合到視圖時，將不考慮選擇此項目的對象。 通常地板和類似物會被這樣標記。另請參閱適合視圖的工具欄按鈕和sim.cameraFitToView api函數。 \n \n Cannot be deleted during simul. : when enabled, then the object will ignore a deletion operation when a simulation is running (deletion will however still work when triggered via code). \n \n 無法在模擬過程中刪除： 啟用後，對象將在模擬運行時忽略刪除操作 （但是，通過代碼觸發後，刪除仍然可以進行）。 \n \n Cannot be deleted : when enabled, then the object will ignore a deletion operation (deletion will however still work when triggered via code). \n \n 無法刪除： 啟用後，該對象將忽略刪除操作 （但是，通過代碼觸發後，刪除仍將起作用）。 \n \n Extension string :  a string that describes additional object properties, mainly used by extension plugins (see also the \xa0 sim.getExtensionString \xa0 API function). \n \n 擴展字符串： 描述附加對象屬性的字符串，主要由擴展插件使用 （另請參見sim.getExtensionString API函數）。 \n \n Camera visibility layers : each object in CoppeliaSim can be assigned to one or several visibility layers. If there is at least one visibility layer that matches the \xa0 layer selection dialog \xa0 layers, then the object will be visible when seen from a camera. By default, a \xa0 shape \xa0 is assigned to the first layer, a \xa0 joint \xa0 to the second layer, a \xa0 dummy \xa0 to the third layer, etc. \n \n 攝像機可見性層： 可以將CoppeliaSim中的每個對象分配給一個或多個可見性層。如果至少有一個與圖層選擇對話框圖層匹配的可見性圖層，則從攝像機看時該對象將可見。 默認情況下，將形狀分配給第一層，將關節分配給第二層，將虛擬對象分配給第三層，等等。 \n \n Can be seen by : allows to specify a \xa0 camera \xa0 or \xa0 vision sensor \xa0 (or a \xa0 collection \xa0 containing cameras or vision sensors) that will be the only one able to see the object. \n \n 可以通過以下方式看到： 允許指定將是唯一能夠看到對象的攝像機或視覺傳感器 （或包含攝像機或視覺傳感器的集合）。 \n \n Collidable : allows enabling or disabling \xa0 collision detection \xa0 capability for the selected \xa0 collidable object . \n \n 可碰撞： 允許為選定的可碰撞對象啟用或禁用碰撞檢測功能。 \n \n Measurable : allows enabling or disabling \xa0 minimum distance calculation \xa0 capability for the selected \xa0 measurable object . \n \n 可測量的： 允許啟用或禁用所選可測量對象的最小距離計算功能。 \n \n Detectable : allows enabling or disabling \xa0 proximity sensor \xa0 detection capability for the selected \xa0 detectable object . Clicking \xa0 details \xa0 allows you to edit the detectable details. \n \n 可檢測： 允許為選定的可檢測對象啟用或禁用接近傳感器檢測功能。 單擊詳細信息可讓您編輯可檢測的詳細信息。 \n \n Renderable : allows enabling or disabling the \xa0 vision sensor \xa0 detection capability for the selected \xa0 renderable object . \n \n 可渲染： 允許為選定的可渲染對象啟用或禁用視覺傳感器檢測功能。 \n \n Object is model base : indicates whether the object should act as the base of a \xa0 model . An object flagged as \xa0 base of model \xa0 has special properties (e.g. saving or copying the object will also automatically save/copy all its children and children's children, etc.). Additionally, when such an object is selected, the selection bounding box is displayed as thick stippled lines, encompassing the whole model. Refer to \xa0 models , and to the \xa0 select base of model instead \xa0 item above. \n \n 對像是模型的基礎： 指示對像是否應充當模型的基礎。標記為模型基礎的對象具有特殊屬性 （例如，保存或複制該對像還將自動保存/複製其所有子對像以及子對象的子對象等）。另外， 當選擇了此類對象時，選擇邊界框將顯示為點狀的粗線，包圍整個模型。 請參考模型，並參考上面的模型選擇模型。 \n \n Edit model properties : allows opening the \xa0 model dialog . \n \n 編輯模型屬性： 允許打開模型對話框。 \n \n Object / model can transfer or accept DNA : \xa0 when this feature is enabled for an object or a model, then it will share a same identifier with all of its copies. An Object or model can then transfer its DNA (i.e. copy an instance of itself) to all of its siblings (i.e. objects/models with the same identifier), via the transfer DNA \xa0 toolbar \xa0 button. Imagine having 100 same robots in your scene that you want to modify in a similar way: simply modify one of them, select it, then click the transfer DNA toolbar button. This item should almost always be checked for a model base (see further up), to facilitate model re-instanciation. \n \n 對象/模型可以轉移或接受DNA： 當為對像或模型啟用此功能時，它將與所有副本共享相同的標識符。 然後，對像或模型可以通過轉移DNA工具欄按鈕將其DNA （即復制其自身的實例） 轉移到其所有同級兄弟 （即具有相同標識符的對象/模型）。 想像一下，您要以類似的方式修改場景中的100個相同的機器人：只需修改其中一個，選擇它，然後單擊Transfer DNA工具欄按鈕。 幾乎應始終檢查該項目的模型基礎（請參閱後續部分），以促進模型的重新實例化。 \n \n \n Collection self-collision indicator : when performing collision (or minimum distance) calculations between two identical collections, CoppeliaSim will normally check all collection items against all other items in that collection. In some situation, such as a kinematic chain, one doesn't want to check consecutive links, since they might be constantly colliding at the interface. In that case, you can use the collection self-collision indicator: two items of a same collection will not be checked against each other if their indicator difference is exactly 1, as can be seen on following figure: \n \n 集合自我碰撞指示器： 在兩個相同的集合之間執行碰撞（或最小距離）計算時，CoppeliaSim通常會對照該集合中的所有其他項目檢查所有集合項目。 在某些情況下，例如運動鏈，一個人不想檢查連續的鏈接，因為它們可能在接口處不斷碰撞。 在這種情況下，您可以使用集合自衝突指標： 如果同一集合的兩個項目的指標差恰好為1，則不會相互檢查它們 ，如下圖所示： \n \n \n Scaling : objects or models can be scaled in a flexible way in CoppeliaSim. The size of an object or model, and all related properties are scaled appropriately (e.g. joint ranges, velocity settings, masses, etc.) so that the scaled object or model can normally continue to operate (but at a different scale). \n \n 縮放： 可以在CoppeliaSim中靈活地縮放對像或模型。 適當縮放對像或模型的大小以及所有相關屬性（例如關節範圍，速度設置，質量等） ，以便縮放後的對像或模型可以正常繼續運行（但以不同的比例）。 \n \n Assembling :  opens a dialog that allows to specify how the \xa0 assembling toolbar button \xa0 will handle the object during assembly (if objects are assembled in a different way than via the assembling toolbar button, then following settings will have no influence): \n \n 組裝： 打開一個對話框，該對話框可指定組裝期間工具欄按鈕如何處理對象 （如果對象的組裝方式與通過工具欄按鈕的組裝方式不同，則以下設置將沒有影響）： \n \n \n Required match values for parent : the object can be attached to another object (i.e. become another object's child), but only if one of the listed \xa0 required match values for parent \xa0 matches one of its new parent's \xa0 required match values for child \xa0 values. This feature is useful in order to set a fixture compatibility criteria (e.g. gripper A can only be attached with a robot that has a tooltip of type A). \n \n 母體的必需匹配值： 可以將對象附加到另一個對象（即成為另一個對象的子對象） ，但前提是列出的母體必需匹配值之一與其新母體的子項必需匹配值之一匹配。 此功能對於設置夾具兼容性標準很有用（例如，夾具A只能與工具提示類型為A的機器人連接）。 \n \n Required match values for child : the object can have another object attached to itself (i.e. become another object's parent), but only if one of its \xa0 required match values for child \xa0 matches one of its new child's \xa0 required match values for parent \xa0 values. This feature is useful in order to set a fixture compatibility criteria (e.g. gripper A can only be attached with a robot that has a tooltip of type A). \n \n 子項的必需匹配值： 該對象可以附加另一個對象（即成為另一個對象的母體） ，但前提是其子項的必需匹配值之一與其新子項的主值必需匹配值之一匹配。此功能對於設置夾具兼容性標準很有用（例如，夾具A只能與工具提示類型為A的機器人連接）。 (上述功能的相反操作) \n \n When assembling, a specific local transform. matrix will be applied : if checked, then the object won't stay in place when assembled: a specific transformation matrix will be used as its new local transformation matrix. By default that matrix is the identity matrix, but you can specify a specific matrix by clicking \xa0 Set matrix . This feature is useful in order to automatically position and orient an object correctly in relation to its new parent (e.g. in order to have a gripper automatically placed correctly at a robot's tooltip) \n \n \n 組裝時，進行特定的局部轉換。矩陣將被應用： 如果選中，則對像在組裝時不會停留在原位：特定的變換矩陣將用作其新的局部變換矩陣。 默認情況下，該矩陣是單位矩陣，但是您可以通過單擊設置矩陣來指定特定矩陣。 此功能對於自動相對於其新主對象正確定位和定向對像很有用（例如，為了使抓取器自動正確放置在機器人的工具提示上） \n The object selection order is important for assembly operations, i.e. first select the \xa0 to-become-child-object , then the \xa0 to-become-parent-object . If the selection order is wrong, or if the \xa0 to-become-parent-object \xa0 is not appropriate, then CoppeliaSim will try to guess what the real intention of the user was (e.g. by searching for an appropriate match in the \xa0 to-become-parent-object 's descendents), if there is no ambiguity. \n 對象選擇順序對於組裝操作很重要，即首先選擇要成為子對象的對象，然後選擇要成為母體的對象 。 如果選擇順序有誤，或者如果成為母體的對像不合適，那麼CoppeliaSim將嘗試猜測用戶的真實意圖（例如，藉著尋找合適的匹配項在，成為母體對象的子對象的這件事上），如果沒有模糊的話。 \n \n \n \n Cameras(攝影機) \n Cameras are\xa0 viewable objects , which means that you can \xa0 look through \xa0 them and display a view of what they are \xa0 looking at . You can have as many cameras as needed in your \xa0 scene , each one of them offering a different \xa0 view \xa0 of the scene. Following shows an example of a scene containing several cameras: \n 相機是可見的對象，這意味著您可以瀏覽它們並顯示其所觀看內容的視圖。  您可以根據需要在場景中擁有任意數量的攝像機，每個攝像機都提供不同的場景視圖。 以下是一個包含多個攝像機的場景示例： \n \n Make sure not to mix-up cameras with \xa0 vision sensors . Following are the main differences: \n 確保不要將 攝像機 與 視覺傳感器 混淆。 以下是 主要區別 ： \n \n \n A camera has no specific resolution (i.e. it adjusts automatically to the view size). A vision sensor has a fixed resolution. \n A camera's image content is not directly available via the \xa0 API \xa0 (but via a callback mechanism), and image processing not directly supported. A vision sensor's image content can be accessed via the API, and processed via the \xa0 vision callback functions . \n A camera generally requires less CPU time and operates faster than vision sensors. \n A camera can display all \xa0 object types . A vision sensor can only display \xa0 renderable objects . \n \n \n 相機沒有特定的分辨率（即，它會自動調整為視圖尺寸）。 視覺傳感器具有固定的分辨率。 \n 相機的圖像內容不能通過API直接獲得（而是通過回調機制獲得），並且 不直接支持圖像處理。   視覺傳感器的圖像內容可以通過API進行訪問，並通過視覺回調函數進行處理。 \n 攝像機通常比視覺傳感器需要更少的CPU時間並且運行得更快。 \n 攝像機可以顯示所有對像類型。  視覺傳感器只能顯示可渲染的對象。 \n \n \n A camera can be added to the scene with [Menu bar --> Add --> Camera]. However adding a camera in this way will add the \xa0 object \xa0 in a default position and orientation. It is a better practice to add cameras by right-clicking on a specific view of a scene and selecting [Popup menu --> Add --> Camera]. This will add the object just in front of the current view. The added camera is automatically selected and you can then \xa0 look through it \xa0 with [Popup menu --> View --> Associate view with selected camera]. For this to work you will have to make sure the popup menu is activated on a view. When a view is created but not yet associated with a viewable object, the [Popup menu --> Add --> Camera] command will add a camera and directly associate it with the view (i.e. \xa0 look through it ). A camera can be associated with any number of views. \n 可以使用[菜單欄->添加->攝像機]將攝像機添加到場景中。 但是，以這種方式添加相機會將對象添加到默認位置和方向。  最好通過右鍵單擊場景的特定視圖並選擇[彈出菜單->添加->攝像機]來添加攝像機。 這會將對象添加到當前視圖的前面 。 添加的攝像機會自動選擇，然後您可以使用[彈出菜單->視圖->將視圖與所選攝像機關聯]進行瀏覽。  為此，您必須確保在視圖上激活了彈出菜單。 創建視圖但尚未與可見對象關聯時，[彈出菜單->添加->攝像機]命令將添加攝像機並將其直接與視圖關聯（即瀏覽）。 攝像機可以與任意數量的視圖關聯。 \n Alternatively you can also associate a view with a camera by activating following popup in a view: [Popup menu --> View --> View selector..]. This will allow you to select the desired camera view from a preview window. When a camera is associated with a view, it can be manipulated with the mouse with following toolbar buttons: \n 或者， 您還可以通過激活視圖中的以下彈出窗口來將視圖與攝像機關聯：[彈出菜單->視圖->視圖選擇器..]。 這將允許您從預覽窗口中選擇所需的攝像機視圖。  將相機與視圖關聯時，可以使用以下工具欄按鈕用鼠標對其進行操作： \n \n \n \n Camera angle button : allows adjusting the perspective projection angle of a camera view (when in perspective projection mode), or allows adjusting the view size of a camera view (when in orthogonal projection mode). \n Fit-to-view button : adjusts the camera of the view that has the focus in order to nicely frame all selected objects, or the entire scene if no object is selected. \n \n \n 攝像機角度按鈕： 允許調整攝像機視圖的透視投影角度（在透視投影模式下），或者 允許調整攝像機視圖的視圖尺寸 （在正交投影模式下）。 \n 適合視圖的按鈕： 調整具有焦點的視圖的攝像機， 以很好地構圖所有選定的對象，或者如果沒有選擇任何對象，則對整個場景進行構圖。 \n \n When the camera shift button is activated, it is very easy to navigate in the scene to any desired position and orientation using: (1) the left mouse button for shifting perpendicular to the view direction, (2) the mouse wheel for shifting along the view direction, and (3) the right mouse button for rotating about the clicked point: \n 激活相機移位按鈕後，使用以下方法很容易在場景中導航到任何所需的位置和方向： （1）鼠標左鍵用於垂直於視圖方向的移動；（2）鼠標滾輪用於沿視圖的移動 查看方向，以及（3）鼠標右鍵圍繞點擊點旋轉： \n \n Cameras can automatically track objects (i.e. follow them as they move) by selecting the object to track, then selecting in the appropriate view [Popup menu --> View --> Track selected object]. A tracking camera will keep its position, but automatically adjust its viewing direction in order to always keep the object to track in its view field. This is different from having a camera attached to that object through a parent-child relationship. \n 相機可以通過選擇要跟踪的對象，然後在適當的視圖中選擇[彈出菜單->視圖->跟踪所選對象]，自動跟踪對象（即，跟隨它們移動）。   跟踪攝像機將保持其位置，但會自動調整其查看方向，以始終使對像在其視野中進行跟踪。 這與通過父子關係將攝像機連接到該對像不同。 \n", 'tags': '', 'url': 'Entities(實體).html'}, {'title': 'Simulation(模擬)', 'text': "A simulation in CoppeliaSim can be started, paused and stopped with [Menu bar --> Simulation --> Start/Pause/Stop simulation] or through the related toolbar buttons: \n 可以使用 [菜單欄->模擬->開始/暫停/停止模擬] 或通過相關的工具欄按鈕來啟動，暫停和停止CoppeliaSim中的模擬： \n \n Internally(在內部) ,\xa0the\xa0 simulator(模擬器) \xa0will use\xa0 additional(額外)\xa0intermediate(中間)\xa0 states in order to\xa0 correctly(正確地)\xa0 inform \xa0 scripts (告知腳本) \xa0or programs about what will happen next. Following\xa0state  diagram(狀態圖)\xa0illustrates(說明) \xa0the simulator's \xa0internal(內部) \xa0states: \n 在內部， 模擬器將使用其他中間狀態 ，以正確告知腳本或程序接下來將發生的情況。 \xa0 以下 狀態圖說明了模擬器的內部狀態 ： \n \n . \n Scripts and programs should \xa0 alwaysreact(總是反應) \xa0 according to the current system call function and possibly the simulation state in order to \xa0 behave  correctly(正確運行) . It is good practice to \xa0 divide each(劃分每個) \xa0 control code into \xa0 at\xa0least(至少)\xa0 4 system call functions (e.g. for \xa0 non-threaded(非線性) \xa0 child scripts): \n 腳本和程序應始終根據當前系統調用功能以及可能的模擬狀態進行反應 ，以便正確運行。 優良作法是 將每個控制代碼 至少分為4個系統調用函數 （例如，用於非線程子腳本）： \n \n In itialization(初始化) \xa0function: \xa0 sysCall_init: the function is called only when the script is \xa0 initialized(初始化) . \n \n 初始化函數： sysCall_init：僅在腳本初始化時才調用該函數。 \n \n Actuation(激活 ) \xa0 function: \xa0 sysCall_actuation: the function is called when actuation should happen. \n \n 激活函數 ：sysCall_actuation：應在發生激活時調用該函數。 \n \n Sensing(感測)\xa0 function: \xa0 sysCall_sensing: this function is called when sensing should happen. \n \n 感測功能： sysCall_sensing：應在感測發生時調用此函數。 \n \n Clean-up(清理) \xa0 function: \xa0 sysCall_cleanup: the function is called just before the script is \xa0 de-initialized(未初始化) \xa0 (e.g. at simulation end, or when the script is \xa0 destroyed(銷毀) ). \n \n 清理函數： sysCall_cleanup：該函數在腳本未初始化之前被調用（例如在模擬結束時或腳本被銷毀時)。 \n", 'tags': '', 'url': 'Simulation(模擬).html'}, {'title': 'Assignment 2', 'text': 'MechanicalDesignProcess(機械設計過程) \n . \n PG4 Materials and Processes(材料與工藝) \n 4.1 Cost Versus Time Versus Specification(成本與時間與規格) \n we’ll return to cost considerations of the design. With that reestablishment of this design “touchstone,” we’ll do with more “building blocks” that will be available to the designer to determine the best materials and processes for their enclosure parts. \n 我們將回到設計的成本考慮因素。 通過重新設計“試金石”，我們將 設計更多的“構建基塊”以供設計師使用 確定其外殼零件的最佳材料和工藝。 \n There are cases where prototypes required for the final design need to be developed. These “prototypes” are certainly less cost-sensitive, as it is time that is usually the critical factor here. However, even though the prototype itself may not have a cost-sensitivity, the overall project cost is impacted in the sense that cost is sacrificed for speed just in the prototype portion of the project \n 在某些情況下，需要開發最終設計所需的原型。這些“原型”當然對成本不太敏感，因為時間通常是這裡的關鍵因素。然而， 即使原型本身可能不具有成本敏感性，但整個項目的成本 在某種意義上受到影響，因為僅在原型的一部分中就犧牲了速度成本 該項目 \n Time plays into this “cost picture” very much. The “time-to-market” can be a huge driver in product development. That is, if a certain product isn’t released in some specific time frame (such as the spring planting season or the electronic show before the holidays), that can mean a huge difference to the total sales of the product. So, coupled with cost is the aspect of time. \n 時間在這個“成本圖”中扮演了非常重要的角色。 “上市時間”可能是產品開發的巨大推動力。 也就是說，如果某個產品沒有在某個特定的時間範圍內發布（例如春季播種季節或節假日前的電子展覽），則可能對產品的總銷售額產生巨大的影響。 因此，成本是時間的一部分。 \n Emphasis on time in material/process/manufacturability choice for the early stages of the development process  A “high-production” and cost-reduced product release can come occur in the later stages of the development process \n 1.儘早選擇材料/工藝/可製造性 開發過程的各個階段 \n 2.在產品中可能會出現“高產量”和降低成本的產品發布。 開發過程的後期 \n >>it could have been determined that the overall cost is minimized by a “two-stage” \n 可以確定通過上述“兩階段”將總成本降至最低 \n . \n Cost can also be broken down into several time frames, such as: \n 成本也可以細分為多個時間範圍，例如： \n \n Development cost (until first shipment to customer) \n Ongoing production cost of the product: materials/assembly/overhead \n Service and warranty costs after production \n End-of-life costs such as recycling \n \n 1. 開發成本 （直到首次交付給客戶） \n 2. 產品的持續生產成本：材料/組裝/間接費用 \n 3. 生產後的服務和保修成 本 \n 4. 報廢費用，例如回收利用 \n . \n Basic factors affecting costs: \n 影響成本的基本因素： \n • Materials of the individual parts. \n • Process needed to produce the above parts. \n • Assembly procedure needed to assemble above parts. \n • Testing procedure needed to test above parts and assemblies. \n • Quality control procedures in place to assure parts and assemblies are produced and assembled to specifications. \n • Service (expected or unexpected) requirements are met. \n • 各個零件的材料。 \n • 生產上述零件所需的過程。 \n • 組裝上述零件所需的組裝程序。 \n • 測試上述零件和組件所需的測試程序。 \n • 制定質量控製程序以確保零件和組件的生產 並按照規格組裝。 \n • 滿足服務（預期或意外）要求。 \n 4.3 Materials and Process Choice(材料和工藝的選擇) \n Once a designer has designed a part, the designer must determine the “best” Cost way for that part to be produced. The general items to be determined for each part are: \n 設計人員設計完零件後，必須確定要生產該零件的“最佳”成本方式。每個部分要確定的一般項目是： \n • Material of the part. \n • Finish required for the part (see next section). \n • Dimensional accuracy needed for the part. \n • Process by which that part will be produced (perhaps one process for early needs,prototyping, and preproduction of parts and a different process for mature production of the parts). \n • Quantity needed of the part (say, per quarter, per month, per year). \n • Second operations needed for the part (beyond finishing). \n • Cost requirements for the part. \n • Can this part be combined with another part in the design? Essentially, whatneeds to be determined is whether a single (combined) part can fulfill the functionality of the separate parts . \n • Can the part be made symmetrical (for assembly ease)? Should the part that is almost symmetrical be made a more obvious \n • 零件的材料。 \n • 零件需要的表面處理 （請參閱下一節）。 \n • 零件所需的尺寸精度。 \n • 生產零件的過程 （也許是用於早期需求，原型設計和零件預生產的過程，以及用於零件成熟生產的不同過程）。 \n • 零件所需的數量 （例如，每季度，每月，每年）。 \n • 零件需要的第二次操作 （超出精加工）。 \n • 零件的成本要求。 \n •該部分可以與設計中的另一部分組合嗎？本質上，需要確定的是單個（組合）部分是否可以滿足單獨部分的功能。 \n •零件可以做成對稱的（為了便於組裝）嗎？應該把幾乎對稱的部分做成一個更明顯的非對稱部分嗎？這兩個問題涉及該零件的組裝以及以不正確的方式組裝的可能性。可以僅為使零件對稱而在零件上添加孔或缺口（多餘的）。 \n . \n Considerations for determining material selection for a part: \n 確定零件的材料選擇的注意事項： \n The designer should choose a material that will satisfy (meet or exceed): \n 設計者應選擇滿足（超過）要求的材料： \n \n Strength requirements \n Weight requirements \n Reliability requirements \n Regulatory requirements \n Safety requirements \n Thermal requirements \n Shielding requirements (EMI/RFI) \n Compatibility requirements for metals (galvanic corrosion) \n Elastic requirements (durometer) \n Conductive (or insulating) requirements \n Opaqueness requirements \n Wear requirements \n Aesthetical requirements (touch, visual) \n Acoustical requirements \n Ultraviolet (UV) transmission and resistance requirements \n \n 1. 強度要求 \n 2. 重量要求 \n 3. 可靠性要求 \n 4. 法規要求 \n 5. 安全要求 \n 6. 散熱要求 \n 7. 屏蔽要求 （EMI / RFI） \n 8. 金屬的兼容性要求（電腐蝕） \n 9. 彈性要求 （硬度計） \n 10. 導電（或絕緣）要求 \n 11. 不透明要求 \n 12. 磨損要求 \n 13. 審美要求（觸覺，視覺） \n 14. 聲學要求 \n 4.7\xa0Casting Metals(鑄造金屬) \n There are actually quite a few processes for forming plastics, the same can be said for the casting process. There are many casting techniques. The casting techniques generally vary by: \n 實際上有很多塑料成型工藝，鑄造工藝也可以說相同。 有很多鑄造技術。 鑄造技術通常因以下因素而異： \n • Metal cast • Size range of part normally cast • Tolerances expected to be held by process • Cost of tooling • Part price • Surface finish expectation • Minimum draft recommended • Normal minimum section thickness • Ordering quantity • Normal lead time • Die casting • Permanent mold • Investment (lost wax) • Plaster mold • Ceramic mold • Graphite mold • Resin shell mold • Sand casting \n \n • 金屬鑄件 • 正常鑄造零件的尺寸範圍 • 公差應按工序確定 • 工具成本 • 單價 • 表面光潔度期望 • 建議的最低吃水深度 • 正常最小截面厚度 • 訂購數量 • 正常的交貨時間 • 壓鑄 • 永久模具 • 投資（失蠟 ） • 石膏模具 • 陶瓷模具 • 石墨模具 • 樹脂殼模具 • 砂模鑄造 \n 4.8 Dimensioning/Tolerancing\xa0 ( 尺寸/公差) \n 4.8.1 Choice of “Nominal Dimension”\xa0 (“公稱尺寸”的選擇) \n If this is not done correctly, the parts are in a rather constant state of “not fitting” and “out of tolerance,” and assembly line stop-page will occur. assembly and serviceability, as properly dimensioned and toleranced parts will lead to very smooth manufacturing assembly of those parts.Some comments about the English system of units vs. metric system of units are also appropriate (see separate discussion). I even want to start this discussion with how I actually started design “parts” (which were actually tooling fixtures and jigs to perform machining or welding of parts). \n 如果操作不正確，則零件處於“不適合”和“超出公差”的相當恆定的狀態，並且將發生裝配線停工。 裝配和可維修性，因為適當尺寸和公差的零件將導致這些零件的製造裝配非常順暢。關於英制單位制和公制單位制的一些評論也是適當的（請參閱單獨的討論）。 我什至要開始討論如何實際開始設計“零件”（實際上是工裝夾具和夾具）。 進行零件的機加工或焊接）。 \n 4.8.2 United States Engineering Units Versus International System of Units\xa0 \xa0 \xa0 (美國工程單位與國際單位制) \n My comments about dimensioning/tolerances are useful in either system of units (inches or millimeters). In the United States, we may start a design thinking that 3.000 inches is nominal or “the place to start.” In Europe, the “same” place to start might be 75 millimeters (which is equal to 2.953 inches). If a design starts in the United States at 3.000 inches, those drawings are exactly converted to 3 × 25.4 = 76.2 millimeters if the product is to be manufactured in Europe. I’m trying to make a distinction between “conversion factor” (inches to millimeters) and “designer origin mindset.” So, if I was a designer in the United States (with a US education), who was designing a part for a European firm, I would probably create a design that had its start with an “even” millimeter nominal dimen-sion, so I would start with 75 millimeters as that size (instead of choosing 3.000 inch). \n 我對尺寸/公差的評論在單位制（英寸或毫米）中都非常有用。 在美國，我們可能開始設計時以3.000英寸為標稱尺寸或“起點”。 在歐洲，“相同”的起點可能是75毫米（等於2.953英寸）。 如果設計在美國以3000英寸開始，那麼如果要在歐洲製造產品，則將這些圖紙精確地轉換為3×25.4 = 76.2毫米。 我試圖在“轉換係數”（英寸到毫米）和“設計師出身的思維方式”之間進行區分。 因此，如果我是一位美國設計師（接受過美國教育），當時正在為一家歐洲公司設計零件，那麼我可能會創建一個以“甚至”毫米標稱尺寸開始的設計，因此 我將從75毫米開始（而不是選擇3.000英寸）。 \n 4.8.4 Overall Size and the Design (總體尺寸和設計 為了繼續進行尺寸標註) \n To continue the general topic of dimensioning and how it relates to design, Some constraints will usually be the start of a design. Here are some examples: The general assumptions for the examples are: \n 為了繼續進行尺寸標註及其與設計的一般性主題，通常會遇到一些約束。 \n 這裡有些例子： 這些示例的一般假設為： \n The general assumptions for the examples are: Minimum size and weight, Cost (Chpt4), are required in the design. Minimum clearance between one object and another is 0.010 inch. This obviouslyvaries in a real design and depends on the objects and environment that the enclo-sure will be used. \n 設計中需要最小尺寸和重量，成本（Chpt4）。 一個物體與另一個物體之間的最小間隙為0.010英寸。 顯然，這在實際設計中會有所不同，並且取決於要使用外殼的對象和環境。 \n 4.8.5 Theory of Tolerancing: The Need (4.8.5寬容理論：需要) \n Tolerancing on part dimensions is needed as parts cannot be produced perfectly. Manufacturing techniques do not produce perfect parts. This is probably obvious. The actual amount of tolerance is based on a few (probably competing) factors: \n 由於零件無法完美生產，因此需要零件尺寸公差。 製造技術不能生產出完美的零件。這可能是顯而易見的。 實際的公差量基於幾個（可能是相互競爭的）因素： \n \n 成本 （較大的公差製造成本較低）。 \n 相似的零件 （同一零件）需要互換-所有零件都是 公差必須起作用。 \n 與其他零件配合的零件必須在所有零件都達到其公差極限的情況下執行此操作。因此，指定公差的“ 默認步驟 ”是： \n \n A.Choose the tolerance for the reasonable or most common manufacturing process. \n 選擇合理或最常見的製造過程的公差。 \n B. If the above is acceptable to the design, look to increase the tolerance even more,checking back to acceptability in the overall design. Increasing the tolerance will allow more parts to pass inspection, which should (could) result in overall cost reduction. \n 如果上述設計可接受，請尋求更大的公差，並重新檢查總體設計的可接受性。增加容忍度允許更多零件通過檢查，這將（可能）導致總體成本降低。 \n C. Tighten the tolerance even though the most common manufacturing process will not produce that tolerance if the design dictates that tighter tolerance. Check with the part manufacturer if that tighter tolerance will be achievable (reason-ably) or at what cost.Each dimension (location, hole size, angle, etc.) must have a tolerance, either explicitly stated on the drawing or as being a part of an overall notation on thedrawing. \n 收緊公差，即使最常見的製造工藝在設計要求更嚴格的公差的情況下也不會產生該公差。請與零件製造商聯繫，以確保（合理地）可以達到更嚴格的公差，或者以何種成本實現。每個尺寸（位置，孔的大小，角度等）都必須具有公差，公差可以在圖紙上明確說明，也可以作為圖紙上整體符號的一部分。 \n 4.8.7 Inspection Dimensions (Critical Dimensions) (檢驗尺寸（關鍵尺寸）) \n Parts can have hundreds of dimensions. To fully specify every feature on some parts takes a fair amount of time. Historically, every feature on a drawing was dimen-sioned to enable that feature to be inspected and found either in compliance with the specification (drawing) or non-compliant. With the advent of 3D CAD systems for designing and creating drawing documentation, it is completely possible to transfer all of the part information digitally, without any dimensions being specified actually on the drawing, and have that part manufactured at the “nominal specified dimen-sion.” That is, features that are 3.000 inches apart are “drawn” exactly 3.000 inches apart, and that number is an integral part of a file that the part manufacturer gets.Anyone who brings up that part file on their CAD system can query that file and see those features need to be 3.000 inches apart (with a stated tolerance as a part of the CAD file). In fact, inspection departments, if they had access to the CAD file, could inspect the part \n 零件可以具有數百個尺寸。要完全指定某些零件上的每個功能需要花費大量時間。從歷史上看，對圖紙上的每個特徵都進行了尺寸標註，以便可以檢查和發現該特徵是否符合規範（圖紙）或不符合規範。隨著3D CAD系統的出現 設計和創建工程圖文檔時，完全有可能以數字方式傳輸所有零件信息，而無需在工程圖上實際指定任何尺寸，而使零件以“標稱指定尺寸”進行製造。也就是說，相隔3.000英寸的要素將精確地“繪製” 3.000英寸 零件號是零件製造商獲取的文件的組成部分。在其CAD系統上顯示該零件文件的任何人都可以查詢該文件，並看到這些特徵需要相距3.000英寸（以規定的公差作為單位）。 CAD文件的一部分）。實際上，檢查部門如果可以訪問CAD文件，則可以檢查零件', 'tags': '', 'url': 'Assignment 2.html'}]};