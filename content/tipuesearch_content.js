var tipuesearch = {"pages": [{'title': 'About', 'text': 'Repository ： https://github.com/s40723144/cd2020 \n Website： https://s40723144.github.io/cd2020/content/index.html \n Group\xa0Repository： https://github.com/s40723150/cd2020ag2 \n Group Presentation： https://s40723150.github.io/cd2020ag2/reveal \n Group Website： https://s40723150.github.io/cd2020ag2 \n', 'tags': '', 'url': 'About.html'}, {'title': '紀錄', 'text': '', 'tags': '', 'url': '紀錄.html'}, {'title': 'w3', 'text': '可攜系統更新python3.8.2 \n \n', 'tags': '', 'url': 'w3.html'}, {'title': 'w7', 'text': '直播測試 \n 利用obs串流yt拍直播影片 \n \n 翻譯Assignment1.2和編輯個人簡介 \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'Assignment 1', 'text': '', 'tags': '', 'url': 'Assignment 1.html'}, {'title': 'CoppeliaSim User Manual', 'text': '', 'tags': '', 'url': 'CoppeliaSim User Manual.html'}, {'title': 'User interface(用戶界面)', 'text': 'The CoppeliaSim application is composed by several elements. Its main elements are: \n CoppeliaSim應用程序由幾個元素組成。 它的主要元素是： \n \n \n a console window: \xa0under Windows, when the CoppeliaSim application starts, a console window is created but directly hidden again. \n \n window控制台： 在Windows下，當CoppeliaSim應用 程式啟動時 ，會 創建一個控制台窗口 ，但會直接將其隱藏。 \n \n \xa0 an application window: \xa0the application window is the application\'s main window. It is used to display, edit, simulate and interact with a scene. \n \n window應用程式： 應用程式窗口是應用程式的主窗口。它用於 顯示、編輯模擬 並與場景交互。 \n \n several dialogs:\xa0 next to the application window, the user can also edit and interact with a scene by adjusting dialog settings or parameters.\xa0 \n \n 幾個對話框： 在應用程序窗口旁邊，用戶還可以通過 調整對話框的設置或參數 來編輯和與場景進行交互。 \n \n Following illustrates a typical view of the CoppeliaSim application: \n 以下是CoppeliaSim應用程序的典型視圖： \n \n \n When you launch the CoppeliaSim application, CoppeliaSim will initialized one default scene. The user is free to open several scenes in parallel.\xa0 \n In following section, a brief description will be given of the application window\'s elements. \n 當您啟動CoppeliaSim應用程序時，CoppeliaSim將初始化一個默認場景。 用戶可以自由地並行打開多個場景。 \n 在下一節中，將簡要介紹上圖應用程序窗口的元素。 \n \n \n application bar:  the application bar indicates the type of license of your CoppeliaSim copy, the filename of the scene that is currently being displayed, the time used for one rendering pass (one display pass), and the simulator\'s current state (simulation state or type of the active edit mode).\xa0Supported files include "*.ttt"-files (CoppeliaSim scene files) and "*.ttm"-files (CoppeliaSim model files). \n \n 應用程序欄： 應用程序欄指示您的 CoppeliaSim副本的許可類型，當前正在顯示的場景的文件名 ，一次解釋過程（一次顯示過程）所用的時間以及模擬器的當前狀態（模擬狀態或活動活動類型的編輯模式）。支持的文件包括“ *  .ttt”文件 （CoppeliaSim 場景文件 ）和“ * .ttm”文件（CoppeliaSim 模型文件 ）。 \n \n menu bar:  the menu bar allows accessing almost all functionalities of the simulator. Most of the time, the items in the menu bar activate a dialog. The menu bar content is context-sensitive (i.e. it will depend on the current state of the simulator). Most functions in the menu bar can also alternatively be accessed through a popup menu, a double-click on an icon in the scene hierarchy view, or through a click of a toolbar button. \n \n 菜單欄： 菜單欄 允許進入模擬器的幾乎所有功能 。 大多數時候，菜單欄中的項目會激活一個對話框。 菜單欄的內容是上下文相關的（即，它將取決於模擬器的當前狀態）。 也可以通過 彈出菜單 ，或者 雙擊場景階層 視圖中的圖標又或者 單擊工具欄按鈕 來進入菜單欄中的大多數功能。 \n \n toolbars:  the toolbars present functions that are often accessed (e.g. changing the navigation mode, selecting another page, etc.). Some functions in toolbar 1, and all functions in toolbar 2 can also be accessed through the menu bar or popup menu. See further down for more details. Both toolbars can be docked and undocked, but docking works only with their respective initial positions. Following figure explains each toolbar button\'s function: \n \n 工具欄： 工具欄提供經常進入的功能 （例如，更改導航模式，選擇其他頁面等）。  工具欄1 中的某些功能以及 工具欄2 中的所有功能也可以通過菜單欄或彈出菜單進入。 進一步了解更多細節。  這兩個工具欄都可以停靠任務和取消停靠任務 ，但是停靠任務僅適用於它們各自的初始位置。 下圖說明了每個工具欄按鈕的功能： \n \n \n model browser:  the model browser is visible by default, but can be toggled with its corresponding toolbar button. It displays in its upper part a CoppeliaSim model folder structure, and in its lower part, thumbnails of models contained in the selected folder. Thumbnails can be dragged-and-dropped into the scene to automatically load the related model. Caught thumbnails appears dark if the drop area is not supported or not appropriate. \n \n 模型瀏覽器： 默認情況下，模型瀏覽器是可見的，但可以使用其相應的工具欄按鈕進行切換。 它的 上部顯示CoppeliaSim模型結構的文件夾，下部顯示所選文件夾中包含的模型縮略圖 。 可以將縮略圖拖放到場景中以自動加載相關模型。 如果 拖放區域不受支持或不合適，則捕獲的縮略圖將顯示為黑色 。 \n \n \n \n scene hierarchy: the scene hierarchy is visible by default, but can be toggled with its corresponding toolbar button. It displays the content of a scene (i.e. all scene objects composing a scene). Since \xa0 scene objects \xa0 are built in a hierarchy-like structure, the scene hierarchy displays a tree of this hierarchy, and individual elements can be expanded or collapsed. A double-click on an icon opens/closes a property dialog related to the clicked icon. A double-click on an object name allows editing it. The mouse wheel as well as a drag of the scene hierarchy view\'s scrollbars allows shifting the content up/down or left/right. Control and shift selection is always supported. Objects in the scene hierarchy can be dragged and dropped onto another object, in order to create a parent-child relationship. The scene hierarchy will display a different content if the simulator is in an edit-mode state. Refer to the \xa0 shape edit modes , and the \xa0 path edit mode \xa0 for more information. \n \n \n 場景層次結構： 默認情況下，場景層次結構是可見的，但可以使用其相應的工具欄按鈕進行切換。 它顯示場景的內容（即組成場景的所有場景對象）。 由於場景對像是按類似層次結構的結構構建的，因此 場景層次結構將顯示此層次結構的樹狀圖，並且各個元素都可以展開或折疊。 雙擊圖標可打開/關閉與單擊的圖標相關的屬性對話框。 雙擊對象名稱可以對其進行編輯 。 鼠標滾輪以及場景層次結構視圖的拖動允許向上/向下或向左/向右移動內容。 始終支持控制和換檔選擇。  可以將場景層次結構中的對象拖放到另一個對像上，以創建鄰接表模型 。 如果模擬器處於編輯模式狀態，則場景層次將顯示不同的內容。 有關更多信息，請參考形狀編輯模式和路徑編輯模式。 \n \n \n page:   each \xa0 scene \xa0 may contain up to 8 pages, each of them may contain an unlimited number of views. A page can be seen as container for views. Refer to the \xa0 pages and views section \xa0 for more details. \n \n 頁面： 每個場景最多可包含8個頁面 ，每個頁面可包含不限數量的視圖。可以將頁面視為視圖的容器。請參閱頁面和視圖部分以獲取更多詳細信息。 \n \n views:   there can be an unlimited number of views contained in a page. A view is used to display the scene (itself containing an environment and objects), seen through a \xa0 viewable object \xa0 (e.g. \xa0 cameras , \xa0 graphs \xa0 or \xa0 vision sensors ). \n \n 視圖： 頁面中可以包含無數個視圖。 視圖用於顯示通過可見對象 （例如攝像機，圖形或視覺傳感器） 看到的場景 （本身包含環境和對象）。 \n \n information text:  the information text displays information related to current object/item selection and to running simulation states or parameters. The text display can be toggled with one of the two small buttons on the upper left side of a page. The other button can be used to toggle a white background, giving a better contrast depending on the background color of a scene. \n \n 信息文本： 信息文本顯示與當前對象/項目選擇以及運行模擬狀態或參數有關的信息。可以使用頁面 左上方的兩個小按鈕之一來切換文本顯示。另一個按鈕可用於切換白色背景 ，根據場景的背景顏色提供更好的對比度。 \n \n status bar: \xa0 the status bar displays information related to performed operations, commands, and also displays error messages from the Lua interpreter. From within a\xa0 script \xa0the user can also output strings to the status bar with the\xa0 sim.addStatusbarMessage \xa0function. The status bar displays only two lines by default, but it can be resized using its horizontal separation handle. \n \n 狀態欄： 狀態欄 顯示與執行的操作，命令有關的信息 ，還顯示來自Lua解釋器的錯誤消息 。用戶還可 以從腳本中使用\xa0 (sim.addStatusbarMessage)\xa0 函數將字符串輸出到狀態欄 。默認情況下，狀態欄僅顯示兩行，但可以使用其水平分隔手柄調整其大小。 \n \n Lua commander:   a read-eval-print loop, that adds a text input to the CoppeliaSim status bar, allowing to enter and execute Lua code on the fly, like in a terminal. The code can be run in \xa0 the sandbox script , or any other active script in CoppeliaSim. \n \n Lua指令： 一個讀-評估-打印循環 ，它將文本輸入添加到CoppeliaSim狀態欄，從而可以像在終端機中一樣快速輸入和執行Lua代碼。 該代碼可以在沙盒腳本或CoppeliaSim中的任何其他活動腳本中運行。 \n \n custom user interfaces: \xa0 custom user interfaces \xa0are user-defined UI surfaces that can be used to display information (text, images, etc.) or a custom dialog, allowing to interact with the user in a customized way. \n \n 自定義用戶界面： 自定義用戶界面是用戶定義的UI表面，可用於顯示信息（文本，圖像等）或自定義對話框 ，從而允許以自定義方式與用戶進行交互。 \n \n popup menu:  popup menus are the menus that appear after a right mouse button click. To activate a popup menu, make sure the mouse doesn\'t move during the click operation, otherwise the camera rotation mode may be activated (see the  camera section \xa0for more details). Each surface within the application window (e.g. scene hierarchy view, page, view, etc.) may trigger a different popup menu (context-sensitive). The content of popup menus may also change depending on the current simulation state or edit mode. Most popup menu function can also be accessed through the menu bar, except for the view-menu item that only appears when the popup menu is activated on a view or page. \n \n 彈出菜單：彈出菜單是單擊鼠標右鍵後出現的菜單。要激活彈出菜單，請確保在單擊操作期間鼠標沒有移動，否則可能會激活相機旋轉模式（有關更多詳細信息，請參見相機部分）。應用程序窗口內的每個表面（例如，場景層次視圖，頁面，視圖等）可能會觸發不同的彈出菜單（上下文相關）。 彈出菜單的內容可能根據當前的模擬狀態或編輯模式而改變。除了僅在視圖或頁面上激活彈出菜單時才會顯示的視圖菜單項，大多數彈出菜單功能也可以通過菜單欄進入。', 'tags': '', 'url': 'User interface(用戶界面).html'}, {'title': 'Scenes and models(場景和模型)', 'text': 'Scenes and models are CoppeliaSim\'s main simulation elements. A model is a sub-element of a scene, clearly marked as model. A scene may contain any number of models. Following figure illustrates the scene-model relationship: \n 場景和模型是CoppeliaSim的主要模擬元素。  模型是場景的子元素，明確標記為模型。 場景可以包含任何數量的模型。  下圖說明了場景模型關係： \n \n Scenes(場景) \n Compared to\xa0 models , a scene can contain exactly the same type of elements, but additionally also includes following elements, specific to scenes: \n 與模型相比，場景可以包含完全相同類型的元素，但另外還包括以下特定於場景的元素： \n \n \n \n The environment \n The main script \n Pages and views \n \n \n \n \n \n \n \n 環境 \n 主要腳本 \n 頁面和視圖 \n \n \n A scene or scene image content can be seen through a\xa0 viewable object \xa0 associated with a view, itself contained in a \xa0 page . When creating a new scene ([Menu bar --> File --> New Scene]), the default scene will contain following elements: \n 可以通過與視圖相關聯的可視對象（本身包含在頁面中）來查看場景或場景圖像內容。創建新場景時（ [菜單欄->文件->新場景] ），默認場景將包含以下元素： \n \n \n Several\xa0 camera objects :  cameras allow to \xa0 see \xa0 the scene if they are associated with a view. \n Several\xa0 light objects :  without a light the scene would be hardly visible. The light is used to illuminate the scene. \n Several\xa0 views :  a view is associated with a camera and displays what the camera \xa0 sees . Views are contained in pages. \n Several\xa0 pages :  a page contains one or several views. \n The environment :  the environment is composed by properties as ambient light, fog, background color, etc. \n The floor:  the floor is made-up by\xa0 objects \xa0 grouped in a model. \n The default\xa0 main script :  the default main script should allow running minimal simulations, without the need of \xa0 child scripts . A child script copied into the scene at a later stage will then also be automatically executed (called by the main script) if it is associated with a scene object. \n \n \n 幾個攝影機對象： 如果攝影機與視圖關聯，則可以查看場景。 \n 幾個燈光對象： 沒有燈光，幾乎看不到場景。燈光用於照亮場景。 \n 幾個視圖： 一個視圖與相機關聯，並顯示相機看到的內容。視圖包含在頁面中。 \n 多個頁面： 一個頁麵包含一個或多個視圖。 \n 環境： 環境由環境光，霧，背景色等屬性組成。 \n 地板： 地板是由模型中分組的對象組成的。 \n 默認主腳本： 默認主腳本應允許運行最少的模擬，而無需子腳本 。如果子腳本與場景對象相關聯，則在稍後階段複製到場景中的子腳本也將自動執行（由主腳本調用）。 \n \n \n Scenes can be opened (loaded) with [Menu bar --> File --> Open Scene...] and saved with [Menu bar --> File --> Save Scene] or [Menu Bar --> File --> Save Scene as...]. Scene files ("*.ttt"-files) also support drag and drop operations between the explorer window and the application window. Scene files can also be double-clicked, in which case they will launch the CoppeliaSim application and be opened. \n 可以使用 [菜單欄->文件->打開場景...]打開（加載）場景，並使用[菜單欄->文件->保存場景]或[菜單欄->文件- >將場景另存為...]。 場景文件（“ * .ttt”文件） 還支持資源管理器窗口和應用程序窗口之間的拖放操作。 也可以雙擊場景文件，在這種情況下，它們將啟動CoppeliaSim應用程序並打開。 \n Switching between opened scene can be achieved with a single click in the upper part of the \xa0 scene hierarchy \xa0 (all opened scenes are grouped at the top of the scene hierarchy), or by using the scene selector via its related toolbar button: \n 只需在場景階層結構的上部單擊即可 切換打開的場景 （所有打開的場景都在場景階層結構的頂部分組），或者通 過與其相關的工具欄按鈕使用場景選擇器 來實現： \n \n model(模型) \n A model is a sub-element of a\xa0 scene . A model by itself cannot exist, except in a file ("*.ttm"-file type), nor can it be simulated by itself. A model has to be contained in a scene in order to be operational. \n 模型是場景的子元素。 除了文件（ “ * .ttm”-文件類型 ）外， 模型本身不能存在，也不能通過自身進行模擬。 模型必須包含在場景中才能運行。 \n Models are defined by a selection of\xa0 scene objects \xa0 built on a same hierarchy tree, where the base of the tree has to be an object flagged as \xa0 object is model base . They can be loaded with [Menu bar --> File --> Load model...]. It is however much easier and convenient to load a model with a drag-and-drop operation between the \xa0 model browser \xa0 and a \xa0 scene view . Models can be saved with [Menu bar --> File --> Save model as...], just make sure one single object flagged as \xa0 object is model base \xa0 is selected, otherwise the \xa0 Save model as... -menu item will not be enabled. Make also sure to follow the \xa0 tutorial on how to build a clean simulation model . \n 通過在同一階層樹 狀圖上構建的場景對象的選擇來定義模型，其中樹狀圖的基礎必須是已標記對像是模型基礎的對象。\xa0 可以通過[菜單欄->文件->加載模型...]加載它們。 但是，通過在模型瀏覽器和場景視圖之間進行拖放操作來加載模型更加容易和方便。 可以使用[菜單欄->文件->將模型另存為...]保存模型，只需要確認已標註的單個對象是不是選擇的基礎模型 ，否則將模型另存為...-菜單項 未啟用(沒辦法)。 還請確保遵循有關如何構建清晰仿真模型的教程。 \n A model is defined in following steps: \n 通過以下步驟定義模型： \n \n \n attach all objects that logically belong to the model to a base object, so that the base object is the base of the model tree. \n \n 將邏輯上屬於模型的所有對象附加到基礎對象 ，以便基礎對像是模型樹狀圖的基礎。 \n \n check the\xa0 object is model base -item in the \xa0 object common properties . \n \n 在通用屬性中檢查對象是不是模型基礎項目 \n \n in the same dialog as above, check the\xa0 object/model can transfer or accept DNA -item. This will simplify model re-instanciation if you modify it at a later stage. \n \n 在與上述相同的對話框中， 檢查對象/模型是否可以轉移或接受DNA項目 。 如果稍後進行修改，這將簡化模型的重新實例化。 \n \n in the same dialog as above, clicking\xa0 Edit model properties , you can define special overriding properties (e.g. make the whole model invisible, non-collidable, etc.). That allows to quickly disable some properties for all objects defined in the model. \n \n 在與上述相同的對話框中， 點擊編輯模型屬性，您可以定義特殊的替代屬性（例如，使整個模型不可見，不碰撞等） 。 這樣可以快速禁用模型中定義的所有對象的某些屬性。 \n \n for all objects in the model, except for the base object, check the\xa0 select base of model instead -item in the \xa0 object common properties . This will protect your model: you won\'t be able to directly select individual objects in your model, and you will be able to manipulate your model almost as a single object. \n \n 對於模型中的所有對象（基礎對象除外），請 檢查對象通用屬性中的模型選擇基礎代替項目 。 這將保護您的模型： 您將無法直接選擇模型中的單個對象，並且幾乎可以將其作為單個對象來操作模型。 \n \n for all objects that are normally not visible, check the\xa0 Don\'t show as inside model selection -item. This will make the model bounding box appear in the right size around the model. \n \n 對於通常不常見的所有對象，請選中“不顯示內部模型”選擇項 。 這將使模型邊界框在模型周圍以正確的尺寸顯示。 \n \n think about the role of the model: will you be able to attach it to some other object? (e.g. your model is a gripper that you could attach to a manipulator wrist). Or will you be able to attach some other model to it? (e.g. your model is a manipulator that could accept a gripper model). Once the role is decided, define the model\'s\xa0 assembling behaviour . Refer also to this \xa0 dynamics design consideration . \n \n 考慮一下模型的作用： 您能否將其附加到其他對像上？ （例如，您的模型是可以連接到機械手腕上的抓手）。 還是可以附加一些其他模型？ （例如，您的模型是可以接受機械手模型的操縱器）。  確定角色後，定義模型的組裝行為。   另請參閱此動力學設計注意事項。 \n \n Now, individual objects build on the model base cannot be selected anymore in the scene (selecting them will select the base of the model instead), however they can still be individually selected by holding down the ctrl- and shift-key during selection, or by selecting them in the \xa0 scene hierarchy . In addition to that, when the base object is selected, a stippled bounding box encompassing the whole model is displayed as can be seen in following figure: \n 現在，無法在場景中選擇建立在模型基礎上的單個對象（選擇它們將改為選擇模型的基礎），但是仍然 可以通過在選擇過程中按住ctrl和Shift鍵來單獨選擇它們，或者 通過在場景層次中選擇它們。 除此之外，當選擇基礎對象時，將顯示一個包圍整個模型的點畫邊界框 ，如下圖所示： \n \n Notice the model tag on the left-hand side of the icon of the object flagged as model base: \n 注意標記為模型庫的對像圖標左側的模型標籤： \n \n A double-click on a model tag opens the \xa0 model dialog , where model properties can be adjusted. It is also good practice to collapse a model\'s hierarchy once the model was edited in order to easily identify the number of logically grouped elements/models: \n 雙擊模型標籤可打開模型對話框，可在其中調整模型屬性。  修改模型的階層結構後，就是還不錯折疊模型的階層結構，以輕鬆識別邏輯分組的元素/模型的數量： \n \n Grouping several objects as a model is also important when a\xa0 child script \xa0 accesses the objects programmatically; remember that in CoppeliaSim, objects/models can be duplicated at any time, also during a simulation. In order for the duplicated child script to be able to access the correct objects (not the original objects but the duplicated objects), the child script should always be duplicated at the same time as the objects it accesses. One way to guaranty that is to create a model (as described above) and to make sure the child scripts that access objects in the model are associated with objects that are contained in the model. Best is to associate one child script (there might be secondary child scripts too) with the the base of the model. Refer to the \xa0 accessing objects programmatically section \xa0 for more information. \n 當子腳本以編程方式進入對象時，將多個對象分組成模型也很重要 。 請記住，在CoppeliaSim中，對象/模型可以隨時復制，甚至在模擬過程中也可以復制。  為了使復制的子腳本能夠進入正確的對象 （不是原始對象，而是複制的對象），應始終 在進入子腳本的同時復制子腳本。 保證的一種方法是 創建模型 （如上所述）， 並確保進入模型中對象的子腳本與模型中包含的對象相關聯 。最好是基礎的模型與子腳本（也可能有第二個子腳本）相關聯。 有關更多信息，請參考以編程方式 進入 對象部分。 \n In order for models to be easily combined (i.e. built on top of each other) without any additional modification, it is important to consider what role the model will be playing: will it be dynamically simulated? Will it be attached to other models, or will it accept other models attached to it? The answer to those questions will allow you to select the best object type to work as a model base. Refer to the\xa0 section on designing dynamic simulations \xa0 for more information. \n 為了使模型易於組合（即彼此構建）而無需進行任何其他修改，重要的是要 考 慮模型將扮演什麼角色：可以動態模擬嗎？ 它會被附加到其他型號，還是會接受其他附加模型？   這些問題的答案將使您能夠選擇最佳的對像類型作為模型基礎。  有關更多信息，請參考設計動態仿真部分。 \n Copy and pasting a model behaves exactly like saving the model, then loading it (using however a memory buffer instead of the disk space). Models can be copied from one scene to another like any other object. Model files ("*.ttm"-files) also support drag-and-drop operations between the explorer window and the application window. Model files can also be double-clicked, in which case they will launch the CoppeliaSim application and be loaded into a default scene. \n 複製和粘貼模型的行為其實很像是在保存模型，然後加載 （完全使用內存緩衝區而不是磁盤空間）。 可以像其他任何對像一樣將模型從一個場景複製到另一個場景。  模型文件（“ * .ttm”文件）還支持資源管理器窗口和應用程序窗口之間的拖放操作。 還可以雙擊模型文件，在這種情況下，它們將啟動CoppeliaSim應用程序並加載到默認場景中。 \n The properties of a model can be individually adjusted in the \xa0 model dialog . \n 可以在模型對話框中單獨調整模型的屬性。 \n Model dialog(模型文字框) \n The properties of a model can be individually adjusted in the model dialog. It can be opened with a double-click on a model icon in the \xa0 scene hierarchy : \n 可以在模型對話框中單獨調整模型的屬性。 可以雙擊場景層次中的模型圖標來打開它： \n', 'tags': '', 'url': 'Scenes and models(場景和模型).html'}, {'title': 'Simulation(模擬)', 'text': "A simulation in CoppeliaSim can be started, paused and stopped with [Menu bar --> Simulation --> Start/Pause/Stop simulation] or through the related toolbar buttons: \n 可以使用 [菜單欄->模擬->開始/暫停/停止模擬] 或通過相關的工具欄按鈕來啟動，暫停和停止CoppeliaSim中的模擬： \n \n Internally(在內部) ,\xa0the\xa0 simulator(模擬器) \xa0will use\xa0 additional(額外)\xa0intermediate(中間)\xa0 states in order to\xa0 correctly(正確地)\xa0 inform \xa0 scripts (告知腳本) \xa0or programs about what will happen next. Following\xa0state  diagram(狀態圖)\xa0illustrates(說明) \xa0the simulator's \xa0internal(內部) \xa0states: \n 在內部， 模擬器將使用其他中間狀態 ，以正確告知腳本或程序接下來將發生的情況。 \xa0 以下 狀態圖說明了模擬器的內部狀態 ： \n \n . \n Scripts and programs should \xa0 alwaysreact(總是反應) \xa0 according to the current system call function and possibly the simulation state in order to \xa0 behave  correctly(正確運行) . It is good practice to \xa0 divide each(劃分每個) \xa0 control code into \xa0 at\xa0least(至少)\xa0 4 system call functions (e.g. for \xa0 non-threaded(非線性) \xa0 child scripts): \n 腳本和程序應始終根據當前系統調用功能以及可能的模擬狀態進行反應 ，以便正確運行。 優良作法是 將每個控制代碼 至少分為4個系統調用函數 （例如，用於非線程子腳本）： \n \n In itialization(初始化) \xa0function: \xa0 sysCall_init: the function is called only when the script is \xa0 initialized(初始化) . \n \n 初始化函數： sysCall_init：僅在腳本初始化時才調用該函數。 \n \n Actuation(激活 ) \xa0 function: \xa0 sysCall_actuation: the function is called when actuation should happen. \n \n 激活函數 ：sysCall_actuation：應在發生激活時調用該函數。 \n \n Sensing(感測)\xa0 function: \xa0 sysCall_sensing: this function is called when sensing should happen. \n \n 感測功能： sysCall_sensing：應在感測發生時調用此函數。 \n \n Clean-up(清理) \xa0 function: \xa0 sysCall_cleanup: the function is called just before the script is \xa0 de-initialized(未初始化) \xa0 (e.g. at simulation end, or when the script is \xa0 destroyed(銷毀) ). \n \n 清理函數： sysCall_cleanup：該函數在腳本未初始化之前被調用（例如在模擬結束時或腳本被銷毀時)。 \n", 'tags': '', 'url': 'Simulation(模擬).html'}, {'title': 'Assignment 2', 'text': 'MechanicalDesignProcess(機械設計過程) \n . \n PG4 Materials and Processes(材料與工藝) \n 4.1 Cost Versus Time Versus Specification(成本與時間與規格) \n we’ll return to cost considerations of the design. With that reestablishment of this design “touchstone,” we’ll do with more “building blocks” that will be available to the designer to determine the best materials and processes for their enclosure parts. \n 我們將回到設計的成本考慮因素。 通過重新設計“試金石”，我們將 設計更多的“構建基塊”以供設計師使用 確定其外殼零件的最佳材料和工藝。 \n There are cases where prototypes required for the final design need to be developed. These “prototypes” are certainly less cost-sensitive, as it is time that is usually the critical factor here. However, even though the prototype itself may not have a cost-sensitivity, the overall project cost is impacted in the sense that cost is sacrificed for speed just in the prototype portion of the project \n 在某些情況下，需要開發最終設計所需的原型。這些“原型”當然對成本不太敏感，因為時間通常是這裡的關鍵因素。然而， 即使原型本身可能不具有成本敏感性，但整個項目的成本 在某種意義上受到影響，因為僅在原型的一部分中就犧牲了速度成本 該項目 \n Time plays into this “cost picture” very much. The “time-to-market” can be a huge driver in product development. That is, if a certain product isn’t released in some specific time frame (such as the spring planting season or the electronic show before the holidays), that can mean a huge difference to the total sales of the product. So, coupled with cost is the aspect of time. \n 時間在這個“成本圖”中扮演了非常重要的角色。 “上市時間”可能是產品開發的巨大推動力。 也就是說，如果某個產品沒有在某個特定的時間範圍內發布（例如春季播種季節或節假日前的電子展覽），則可能對產品的總銷售額產生巨大的影響。 因此，成本是時間的一部分。 \n Emphasis on time in material/process/manufacturability choice for the early stages of the development process  A “high-production” and cost-reduced product release can come occur in the later stages of the development process \n 1.儘早選擇材料/工藝/可製造性 開發過程的各個階段 \n 2.在產品中可能會出現“高產量”和降低成本的產品發布。 開發過程的後期 \n >>it could have been determined that the overall cost is minimized by a “two-stage” \n 可以確定通過上述“兩階段”將總成本降至最低 \n . \n Cost can also be broken down into several time frames, such as: \n 成本也可以細分為多個時間範圍，例如： \n \n Development cost (until first shipment to customer) \n Ongoing production cost of the product: materials/assembly/overhead \n Service and warranty costs after production \n End-of-life costs such as recycling \n \n 1. 開發成本 （直到首次交付給客戶） \n 2. 產品的持續生產成本：材料/組裝/間接費用 \n 3. 生產後的服務和保修成 本 \n 4. 報廢費用，例如回收利用 \n . \n Basic factors affecting costs: \n 影響成本的基本因素： \n • Materials of the individual parts. \n • Process needed to produce the above parts. \n • Assembly procedure needed to assemble above parts. \n • Testing procedure needed to test above parts and assemblies. \n • Quality control procedures in place to assure parts and assemblies are produced and assembled to specifications. \n • Service (expected or unexpected) requirements are met. \n • 各個零件的材料。 \n • 生產上述零件所需的過程。 \n • 組裝上述零件所需的組裝程序。 \n • 測試上述零件和組件所需的測試程序。 \n • 制定質量控製程序以確保零件和組件的生產 並按照規格組裝。 \n • 滿足服務（預期或意外）要求。 \n 4.3 Materials and Process Choice(材料和工藝的選擇) \n Once a designer has designed a part, the designer must determine the “best” Cost way for that part to be produced. The general items to be determined for each part are: \n 設計人員設計完零件後，必須確定要生產該零件的“最佳”成本方式。每個部分要確定的一般項目是： \n • Material of the part. \n • Finish required for the part (see next section). \n • Dimensional accuracy needed for the part. \n • Process by which that part will be produced (perhaps one process for early needs,prototyping, and preproduction of parts and a different process for mature production of the parts). \n • Quantity needed of the part (say, per quarter, per month, per year). \n • Second operations needed for the part (beyond finishing). \n • Cost requirements for the part. \n • Can this part be combined with another part in the design? Essentially, whatneeds to be determined is whether a single (combined) part can fulfill the functionality of the separate parts . \n • Can the part be made symmetrical (for assembly ease)? Should the part that is almost symmetrical be made a more obvious \n • 零件的材料。 \n • 零件需要的表面處理 （請參閱下一節）。 \n • 零件所需的尺寸精度。 \n • 生產零件的過程 （也許是用於早期需求，原型設計和零件預生產的過程，以及用於零件成熟生產的不同過程）。 \n • 零件所需的數量 （例如，每季度，每月，每年）。 \n • 零件需要的第二次操作 （超出精加工）。 \n • 零件的成本要求。 \n •該部分可以與設計中的另一部分組合嗎？本質上，需要確定的是單個（組合）部分是否可以滿足單獨部分的功能。 \n •零件可以做成對稱的（為了便於組裝）嗎？應該把幾乎對稱的部分做成一個更明顯的非對稱部分嗎？這兩個問題涉及該零件的組裝以及以不正確的方式組裝的可能性。可以僅為使零件對稱而在零件上添加孔或缺口（多餘的）。 \n . \n Considerations for determining material selection for a part: \n 確定零件的材料選擇的注意事項： \n The designer should choose a material that will satisfy (meet or exceed): \n 設計者應選擇滿足（超過）要求的材料： \n \n Strength requirements \n Weight requirements \n Reliability requirements \n Regulatory requirements \n Safety requirements \n Thermal requirements \n Shielding requirements (EMI/RFI) \n Compatibility requirements for metals (galvanic corrosion) \n Elastic requirements (durometer) \n Conductive (or insulating) requirements \n Opaqueness requirements \n Wear requirements \n Aesthetical requirements (touch, visual) \n Acoustical requirements \n Ultraviolet (UV) transmission and resistance requirements \n \n 1. 強度要求 \n 2. 重量要求 \n 3. 可靠性要求 \n 4. 法規要求 \n 5. 安全要求 \n 6. 散熱要求 \n 7. 屏蔽要求 （EMI / RFI） \n 8. 金屬的兼容性要求（電腐蝕） \n 9. 彈性要求 （硬度計） \n 10. 導電（或絕緣）要求 \n 11. 不透明要求 \n 12. 磨損要求 \n 13. 審美要求（觸覺，視覺） \n 14. 聲學要求 \n 4.7\xa0Casting Metals(鑄造金屬) \n There are actually quite a few processes for forming plastics, the same can be said for the casting process. There are many casting techniques. The casting techniques generally vary by: \n 實際上有很多塑料成型工藝，鑄造工藝也可以說相同。 有很多鑄造技術。 鑄造技術通常因以下因素而異： \n • Metal cast • Size range of part normally cast • Tolerances expected to be held by process • Cost of tooling • Part price • Surface finish expectation • Minimum draft recommended • Normal minimum section thickness • Ordering quantity • Normal lead time • Die casting • Permanent mold • Investment (lost wax) • Plaster mold • Ceramic mold • Graphite mold • Resin shell mold • Sand casting \n \n • 金屬鑄件 • 正常鑄造零件的尺寸範圍 • 公差應按工序確定 • 工具成本 • 單價 • 表面光潔度期望 • 建議的最低吃水深度 • 正常最小截面厚度 • 訂購數量 • 正常的交貨時間 • 壓鑄 • 永久模具 • 投資（失蠟 ） • 石膏模具 • 陶瓷模具 • 石墨模具 • 樹脂殼模具 • 砂模鑄造 \n 4.8 Dimensioning/Tolerancing\xa0 ( 尺寸/公差) \n 4.8.1 Choice of “Nominal Dimension”\xa0 (“公稱尺寸”的選擇) \n If this is not done correctly, the parts are in a rather constant state of “not fitting” and “out of tolerance,” and assembly line stop-page will occur. assembly and serviceability, as properly dimensioned and toleranced parts will lead to very smooth manufacturing assembly of those parts.Some comments about the English system of units vs. metric system of units are also appropriate (see separate discussion). I even want to start this discussion with how I actually started design “parts” (which were actually tooling fixtures and jigs to perform machining or welding of parts). \n 如果操作不正確，則零件處於“不適合”和“超出公差”的相當恆定的狀態，並且將發生裝配線停工。 裝配和可維修性，因為適當尺寸和公差的零件將導致這些零件的製造裝配非常順暢。關於英制單位制和公制單位制的一些評論也是適當的（請參閱單獨的討論）。 我什至要開始討論如何實際開始設計“零件”（實際上是工裝夾具和夾具）。 進行零件的機加工或焊接）。 \n 4.8.2 United States Engineering Units Versus International System of Units\xa0 \xa0 \xa0 (美國工程單位與國際單位制) \n My comments about dimensioning/tolerances are useful in either system of units (inches or millimeters). In the United States, we may start a design thinking that 3.000 inches is nominal or “the place to start.” In Europe, the “same” place to start might be 75 millimeters (which is equal to 2.953 inches). If a design starts in the United States at 3.000 inches, those drawings are exactly converted to 3 × 25.4 = 76.2 millimeters if the product is to be manufactured in Europe. I’m trying to make a distinction between “conversion factor” (inches to millimeters) and “designer origin mindset.” So, if I was a designer in the United States (with a US education), who was designing a part for a European firm, I would probably create a design that had its start with an “even” millimeter nominal dimen-sion, so I would start with 75 millimeters as that size (instead of choosing 3.000 inch). \n 我對尺寸/公差的評論在單位制（英寸或毫米）中都非常有用。 在美國，我們可能開始設計時以3.000英寸為標稱尺寸或“起點”。 在歐洲，“相同”的起點可能是75毫米（等於2.953英寸）。 如果設計在美國以3000英寸開始，那麼如果要在歐洲製造產品，則將這些圖紙精確地轉換為3×25.4 = 76.2毫米。 我試圖在“轉換係數”（英寸到毫米）和“設計師出身的思維方式”之間進行區分。 因此，如果我是一位美國設計師（接受過美國教育），當時正在為一家歐洲公司設計零件，那麼我可能會創建一個以“甚至”毫米標稱尺寸開始的設計，因此 我將從75毫米開始（而不是選擇3.000英寸）。 \n 4.8.4 Overall Size and the Design (總體尺寸和設計 為了繼續進行尺寸標註) \n To continue the general topic of dimensioning and how it relates to design, Some constraints will usually be the start of a design. Here are some examples: The general assumptions for the examples are: \n 為了繼續進行尺寸標註及其與設計的一般性主題，通常會遇到一些約束。 \n 這裡有些例子： 這些示例的一般假設為： \n The general assumptions for the examples are: Minimum size and weight, Cost (Chpt4), are required in the design. Minimum clearance between one object and another is 0.010 inch. This obviouslyvaries in a real design and depends on the objects and environment that the enclo-sure will be used. \n 設計中需要最小尺寸和重量，成本（Chpt4）。 一個物體與另一個物體之間的最小間隙為0.010英寸。 顯然，這在實際設計中會有所不同，並且取決於要使用外殼的對象和環境。 \n 4.8.5 Theory of Tolerancing: The Need (4.8.5寬容理論：需要) \n Tolerancing on part dimensions is needed as parts cannot be produced perfectly. Manufacturing techniques do not produce perfect parts. This is probably obvious. The actual amount of tolerance is based on a few (probably competing) factors: \n 由於零件無法完美生產，因此需要零件尺寸公差。 製造技術不能生產出完美的零件。這可能是顯而易見的。 實際的公差量基於幾個（可能是相互競爭的）因素： \n \n 成本 （較大的公差製造成本較低）。 \n 相似的零件 （同一零件）需要互換-所有零件都是 公差必須起作用。 \n 與其他零件配合的零件必須在所有零件都達到其公差極限的情況下執行此操作。因此，指定公差的“ 默認步驟 ”是： \n \n A.Choose the tolerance for the reasonable or most common manufacturing process. \n 選擇合理或最常見的製造過程的公差。 \n B. If the above is acceptable to the design, look to increase the tolerance even more,checking back to acceptability in the overall design. Increasing the tolerance will allow more parts to pass inspection, which should (could) result in overall cost reduction. \n 如果上述設計可接受，請尋求更大的公差，並重新檢查總體設計的可接受性。增加容忍度允許更多零件通過檢查，這將（可能）導致總體成本降低。 \n C. Tighten the tolerance even though the most common manufacturing process will not produce that tolerance if the design dictates that tighter tolerance. Check with the part manufacturer if that tighter tolerance will be achievable (reason-ably) or at what cost.Each dimension (location, hole size, angle, etc.) must have a tolerance, either explicitly stated on the drawing or as being a part of an overall notation on thedrawing. \n 收緊公差，即使最常見的製造工藝在設計要求更嚴格的公差的情況下也不會產生該公差。請與零件製造商聯繫，以確保（合理地）可以達到更嚴格的公差，或者以何種成本實現。每個尺寸（位置，孔的大小，角度等）都必須具有公差，公差可以在圖紙上明確說明，也可以作為圖紙上整體符號的一部分。 \n 4.8.7 Inspection Dimensions (Critical Dimensions) (檢驗尺寸（關鍵尺寸）) \n Parts can have hundreds of dimensions. To fully specify every feature on some parts takes a fair amount of time. Historically, every feature on a drawing was dimen-sioned to enable that feature to be inspected and found either in compliance with the specification (drawing) or non-compliant. With the advent of 3D CAD systems for designing and creating drawing documentation, it is completely possible to transfer all of the part information digitally, without any dimensions being specified actually on the drawing, and have that part manufactured at the “nominal specified dimen-sion.” That is, features that are 3.000 inches apart are “drawn” exactly 3.000 inches apart, and that number is an integral part of a file that the part manufacturer gets.Anyone who brings up that part file on their CAD system can query that file and see those features need to be 3.000 inches apart (with a stated tolerance as a part of the CAD file). In fact, inspection departments, if they had access to the CAD file, could inspect the part \n 零件可以具有數百個尺寸。要完全指定某些零件上的每個功能需要花費大量時間。從歷史上看，對圖紙上的每個特徵都進行了尺寸標註，以便可以檢查和發現該特徵是否符合規範（圖紙）或不符合規範。隨著3D CAD系統的出現 設計和創建工程圖文檔時，完全有可能以數字方式傳輸所有零件信息，而無需在工程圖上實際指定任何尺寸，而使零件以“標稱指定尺寸”進行製造。也就是說，相隔3.000英寸的要素將精確地“繪製” 3.000英寸 零件號是零件製造商獲取的文件的組成部分。在其CAD系統上顯示該零件文件的任何人都可以查詢該文件，並看到這些特徵需要相距3.000英寸（以規定的公差作為單位）。 CAD文件的一部分）。實際上，檢查部門如果可以訪問CAD文件，則可以檢查零件', 'tags': '', 'url': 'Assignment 2.html'}]};